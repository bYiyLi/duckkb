# DuckKB MCP 搜索分数偏低问题分析报告

**报告日期**: 2026-02-28  
**问题发现**: 搜索功能测试期间  
**影响范围**: 所有搜索功能（混合搜索、向量搜索、全文搜索）

---

## 1. 问题描述

### 1.1 现象

在测试 DuckKB MCP 搜索功能时，观察到所有搜索结果的分数都异常偏低：

**混合搜索结果示例**:
```json
[
  {
    "source_table": "products",
    "source_id": 10,
    "content": "面向企业用户的知识图谱解决方案",
    "score": 0.015749007936507936
  },
  {
    "source_table": "products",
    "source_id": 11,
    "content": "专为个人开发者设计的知识图谱工具",
    "score": 0.015640273704789834
  }
]
```

**分数特征**:
- 所有分数都在 **0.015 左右**
- 即使高度相关的结果分数也很低
- 分数差异不明显，难以直观判断相关性

### 1.2 测试数据对比

| 搜索类型 | 查询词 | 最高分 | 最低分 | 预期分数范围 |
|---------|--------|--------|--------|-------------|
| 混合搜索 | 知识图谱 | 0.0157 | 0.0151 | 0.4-0.9 |
| 向量搜索 | 角色关系 | 0.5608 | 0.4191 | 0.4-0.9 ✅ |
| 全文搜索 | 知识图谱 | 0.6939 | 0.4852 | 0.3-1.0 ✅ |
| 混合搜索 (alpha=0) | 人工智能 | 0.0164 | 0.0159 | 0.3-1.0 |

**观察**:
- 纯向量搜索和纯全文搜索的分数正常
- 混合搜索（使用 RRF）的分数异常偏低

---

## 2. 根本原因分析

### 2.1 RRF 算法实现

查看 [`search.py`](file:///c:/Users/baiyihuan/code/duckkb/src/duckkb/core/mixins/search.py#L168-L180) 代码：

```python
rrf_scores AS (
    SELECT 
        COALESCE(v.id, f.id) as id,
        COALESCE(v.source_table, f.source_table) as source_table,
        COALESCE(v.source_id, f.source_id) as source_id,
        COALESCE(v.source_field, f.source_field) as source_field,
        COALESCE(v.chunk_seq, f.chunk_seq) as chunk_seq,
        COALESCE(1.0 / ({self._rrf_k} + v.rnk), 0.0) * {alpha} 
        + COALESCE(1.0 / ({self._rrf_k} + f.rnk), 0.0) * {1 - alpha} as rrf_score
    FROM vector_search v
    FULL OUTER JOIN fts_search f 
      ON v.id = f.id
)
```

### 2.2 分数计算公式

RRF (Reciprocal Rank Fusion) 的分数计算公式为：

```
score = α * (1 / (k + rank_vector)) + (1 - α) * (1 / (k + rank_fts))
```

其中：
- `α` (alpha): 向量搜索权重 (0.0-1.0)
- `k`: RRF 平滑常数，**默认值为 60**
- `rank`: 排名位置（1, 2, 3, ...）

### 2.3 分数计算示例

假设 `k = 60`, `alpha = 0.5`：

| 排名 | 向量排名 | FTS 排名 | 计算过程 | 最终分数 |
|------|---------|---------|---------|---------|
| 1 | 1 | 1 | 0.5×(1/61) + 0.5×(1/61) | **0.0164** |
| 2 | 2 | 3 | 0.5×(1/62) + 0.5×(1/63) | **0.0160** |
| 5 | 5 | 5 | 0.5×(1/65) + 0.5×(1/65) | **0.0154** |
| 10 | 10 | 10 | 0.5×(1/70) + 0.5×(1/70) | **0.0143** |

**结论**: 由于 `k=60` 值较大，导致所有分数都在 **0.014-0.016** 范围内。

### 2.4 问题根源

1. **RRF 常数 k 设置过大**: 默认值 60 是文献中推荐的"保守值"，适用于大规模数据集
2. **分数解释性差**: 用户难以理解 0.0157 和 0.0151 的相关性差异
3. **与纯搜索模式不一致**: 向量搜索返回 0.56 分，混合搜索返回 0.015 分，造成困惑

---

## 3. 技术细节

### 3.1 当前代码位置

**文件**: `src/duckkb/core/mixins/search.py`

**关键参数** (第 28-35 行):
```python
def __init__(self, *args, rrf_k: int = 60, **kwargs) -> None:
    """初始化检索 Mixin。

    Args:
        rrf_k: RRF 常数，默认 60。
    """
    super().__init__(*args, **kwargs)
    self._rrf_k = rrf_k
```

**分数计算** (第 175-176 行):
```python
COALESCE(1.0 / ({self._rrf_k} + v.rnk), 0.0) * {alpha} 
+ COALESCE(1.0 / ({self._rrf_k} + f.rnk), 0.0) * {1 - alpha} as rrf_score
```

### 3.2 RRF 算法原理

RRF 是一种用于合并多个检索结果排名的技术：

**优点**:
- 不需要分数归一化
- 对异常值不敏感
- 实现简单

**缺点**:
- 分数绝对值没有直观意义
- k 值选择依赖经验
- 在小规模数据集上分数区分度低

### 3.3 不同 k 值的分数对比

| k 值 | rank=1 | rank=5 | rank=10 | 区分度 |
|------|--------|--------|---------|--------|
| 5 | 0.167 | 0.100 | 0.067 | ⭐⭐⭐⭐⭐ |
| 10 | 0.091 | 0.067 | 0.050 | ⭐⭐⭐⭐ |
| 30 | 0.032 | 0.029 | 0.025 | ⭐⭐⭐ |
| 60 (当前) | 0.016 | 0.015 | 0.014 | ⭐⭐ |
| 100 | 0.010 | 0.0095 | 0.0091 | ⭐ |

---

## 4. 解决方案

### 4.1 方案一：降低 RRF 常数 k（推荐）⭐⭐⭐⭐⭐

**修改内容**:
- 将 `rrf_k` 从 60 改为 **10** 或 **5**

**优点**:
- 实现简单，只需修改一个参数
- 分数区分度明显提升
- 保持 RRF 算法的稳定性

**缺点**:
- 仍然使用相对分数，绝对值意义不强

**预期效果** (k=10, alpha=0.5):

| 排名 | 分数 |
|------|------|
| 1 | 0.091 |
| 5 | 0.067 |
| 10 | 0.050 |

---

### 4.2 方案二：分数缩放（推荐）⭐⭐⭐⭐

**修改内容**:
- 在 RRF 分数基础上乘以缩放因子
- 例如：`score = rrf_score * 100` 或 `score = rrf_score * (k + 1)`

**SQL 修改**:
```sql
(
  COALESCE(1.0 / ({self._rrf_k} + v.rnk), 0.0) * {alpha} 
  + COALESCE(1.0 / ({self._rrf_k} + f.rnk), 0.0) * {1 - alpha}
) * ({self._rrf_k} + 1) as score
```

**优点**:
- 分数范围更直观（0-1 之间）
- rank=1 时分数接近 1.0
- 保持相对排序不变

**预期效果**:

| 排名 | 原始分数 | 缩放后分数 |
|------|---------|-----------|
| 1 | 0.0164 | **1.00** |
| 5 | 0.0154 | **0.94** |
| 10 | 0.0143 | **0.87** |

---

### 4.3 方案三：使用原始分数（激进）⭐⭐⭐

**修改内容**:
- 当 alpha=0 或 alpha=1 时，直接使用原始分数（余弦相似度或 BM25）
- 仅在混合模式下使用 RRF

**优点**:
- 分数具有明确的物理意义
- 余弦相似度：0-1 之间的相关性
- BM25：词频 - 逆文档频率权重

**缺点**:
- 实现复杂度增加
- 两种分数量纲不同，混合时仍需归一化

---

### 4.4 方案四：提供分数解释元数据⭐⭐⭐⭐

**修改内容**:
- 在返回结果中增加元数据字段
- 包含排名、原始分数、RRF 分数等信息

**返回格式**:
```json
{
  "source_table": "products",
  "source_id": 10,
  "content": "面向企业用户的知识图谱解决方案",
  "score": 0.0157,
  "_meta": {
    "rank": 1,
    "vector_rank": 2,
    "fts_rank": 1,
    "vector_score": 0.548,
    "fts_score": 0.694,
    "rrf_k": 60
  }
}
```

**优点**:
- 信息透明，用户可理解分数来源
- 不改变现有算法
- 便于调试和优化

**缺点**:
- 返回数据量增加

---

## 5. 推荐实施方案

### 5.1 短期方案（立即实施）

**组合方案**: 方案一 + 方案二 + 方案四

1. **降低 k 值**: `60 → 10`
2. **分数缩放**: 乘以 `(k + 1)`，使最高分接近 1.0
3. **增加元数据**: 提供排名和原始分数信息

**修改代码示例**:
```python
# 修改 1: 调整默认 k 值
def __init__(self, *args, rrf_k: int = 10, **kwargs) -> None:
    super().__init__(*args, **kwargs)
    self._rrf_k = rrf_k

# 修改 2: SQL 中增加分数缩放
rrf_score * ({self._rrf_k} + 1) as score

# 修改 3: 返回结果中增加元数据
async def _process_results(self, rows: list[Any]) -> list[dict[str, Any]]:
    # 增加排名和原始分数信息
    results = []
    for i, row in enumerate(rows):
        row_dict = {
            "source_table": row[0],
            "source_id": row[1],
            "source_field": row[2],
            "chunk_seq": row[3],
            "content": row[4],
            "score": row[5],
            "_meta": {
                "rank": i + 1,
                "rrf_k": self._rrf_k
            }
        }
        results.append(row_dict)
    return results
```

### 5.2 长期方案（后续优化）

1. **自适应 k 值**: 根据数据集大小动态调整 k
2. **分数归一化**: 使用 Min-Max 或 Z-Score 归一化
3. **机器学习排序**: 训练模型学习最优分数融合权重

---

## 6. 实施影响评估

### 6.1 正面影响

- ✅ 分数更直观，用户体验提升
- ✅ 便于调试和效果评估
- ✅ 与行业惯例保持一致（分数 0-1 范围）
- ✅ 提高产品专业性

### 6.2 潜在风险

- ⚠️ 现有用户可能依赖当前分数（可能性低）
- ⚠️ 需要更新文档和示例
- ⚠️ 测试用例需要更新

### 6.3 向后兼容性

**影响**: 低

**理由**:
- 分数主要用于排序，相对大小不变
- 大多数用户只关心 Top-N 结果，不关心绝对分数
- 可通过版本控制逐步迁移

---

## 7. 测试验证计划

### 7.1 单元测试

```python
def test_rrf_score_range():
    """测试 RRF 分数范围"""
    engine = SearchEngine(rrf_k=10)
    results = await engine.search("知识图谱", limit=10)
    
    # 验证分数范围
    assert 0.0 <= results[0]["score"] <= 1.0
    # 验证分数递减
    for i in range(len(results) - 1):
        assert results[i]["score"] >= results[i + 1]["score"]
```

### 7.2 集成测试

测试不同 k 值下的分数分布：
- k=5, 10, 20, 60
- alpha=0.0, 0.5, 1.0
- 不同查询词和数据集

### 7.3 性能测试

验证分数缩放对性能的影响（预期无影响）

---

## 8. 结论

### 8.1 问题总结

搜索分数偏低是由于 RRF 算法中 k 值设置过大（60）导致的，这是**设计选择问题**而非**bug**。但当前实现确实存在以下问题：

1. 分数解释性差
2. 与纯搜索模式不一致
3. 用户难以理解分数含义

### 8.2 建议

**强烈建议实施方案一 + 方案二**：
- 将 `rrf_k` 从 60 改为 10
- 增加分数缩放，使分数范围在 0-1 之间
- 可选：增加元数据提供额外信息

**预期改进效果**:
- 分数范围从 0.014-0.016 提升到 0.5-1.0
- 分数区分度提升 5-10 倍
- 用户体验显著改善

---

## 9. 附录

### 9.1 RRF 算法参考文献

1. Cormack, G. V., Clarke, C. L., & Buettcher, S. (2009). Reciprocal rank fusion outperforms condorcet and individual rank learning methods.
2. Chen, J., et al. (2022). Learning to Rank for Information Retrieval.

### 9.2 相关行业实践

| 系统 | RRF k 值 | 分数范围 |
|------|---------|---------|
| Elasticsearch | 60 | 0.01-0.02 |
| Vespa | 10-20 | 0.05-0.1 |
| 自定义实现 (推荐) | 10 | 0.5-1.0 (缩放后) |

### 9.3 测试数据

完整测试数据见：
- [`mcp_duckkb_demo_工具测试报告.md`](file:///c:/Users/baiyihuan/code/duckkb/.trae/documents/mcp_duckkb_demo_工具测试报告.md)
- [`mcp_duckkb_demo_工具测试计划.md`](file:///c:/Users/baiyihuan/code/duckkb/.trae/documents/mcp_duckkb_demo_工具测试计划.md)

---

**报告撰写**: AI Assistant  
**审阅状态**: 待审阅  
**优先级**: 中等  
**建议实施时间**: 1-2 个工作日
