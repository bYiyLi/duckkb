# DuckKB å¹¶å‘å®‰å…¨æ€§åˆ†ææŠ¥å‘Š

## ä¸€ã€é—®é¢˜æ¦‚è¿°

åˆ†æ DuckKB çŸ¥è¯†åº“åœ¨ä»¥ä¸‹åœºæ™¯çš„å¹¶å‘å®‰å…¨æ€§ï¼š

1. æ•°æ®å¯¼å…¥ä¸æŸ¥è¯¢åŒæ—¶è¿›è¡Œ
2. å¤šä¸ªæŸ¥è¯¢å¹¶å‘æ‰§è¡Œ

## äºŒã€å½“å‰æ¶æ„åˆ†æ

### 2.1 æ•°æ®åº“è¿æ¥ç®¡ç† ([db.py](file:///c:/Users/baiyihuan/code/duckkb/src/duckkb/core/mixins/db.py))

```python
class DBMixin(BaseEngine):
    def __init__(self, *args, **kwargs) -> None:
        self._conn: duckdb.DuckDBPyConnection | None = None

    @property
    def conn(self) -> duckdb.DuckDBPyConnection:
        if self._conn is None:
            self._conn = self._create_connection()  # å•ä¾‹è¿æ¥
        return self._conn
```

**å…³é”®ç‰¹å¾**ï¼š

* ä½¿ç”¨**å•ä¾‹è¿æ¥æ¨¡å¼**ï¼šæ•´ä¸ª Engine å®ä¾‹å…±äº«ä¸€ä¸ªè¿æ¥

* è¿æ¥æ˜¯**æ‡’åŠ è½½**çš„

* ä½¿ç”¨**å†…å­˜æ¨¡å¼** (`duckdb.connect()`)

### 2.2 å¯¼å…¥æ“ä½œå¹¶å‘æ§åˆ¶ ([import\_.py](file:///c:/Users/baiyihuan/code/duckkb/src/duckkb/core/mixins/import_.py))

```python
class ImportMixin(BaseEngine):
    def __init__(self, *args, **kwargs) -> None:
        self._import_lock = asyncio.Lock()  # å¯¼å…¥é”

    async def import_knowledge_bundle(self, temp_file_path: str) -> dict[str, Any]:
        async with self._import_lock:  # ä¿æŠ¤å¯¼å…¥æ“ä½œ
            # ... äº‹åŠ¡å†…æ‰§è¡Œæ‰€æœ‰æ“ä½œ
            self.conn.begin()
            # ... å¯¼å…¥èŠ‚ç‚¹ã€è¾¹ã€æ„å»ºç´¢å¼•
            self.conn.commit()
```

**å…³é”®ç‰¹å¾**ï¼š

* ä½¿ç”¨ `asyncio.Lock()` ä¿æŠ¤å¯¼å…¥æ“ä½œ

* **åŒä¸€æ—¶é—´åªå…è®¸ä¸€ä¸ªå¯¼å…¥æ“ä½œ**

* ä½¿ç”¨**äº‹åŠ¡**åŒ…è£…ï¼Œå¤±è´¥ä¼šå›æ»š

### 2.3 æŸ¥è¯¢æ“ä½œ ([search.py](file:///c:/Users/baiyihuan/code/duckkb/src/duckkb/core/mixins/search.py))

```python
async def search(self, query: str, ...) -> list[dict[str, Any]]:
    # ...
    rows = await asyncio.to_thread(self._execute_query, sql, fts_params)
    return self._process_results(rows)

def _execute_query(self, sql: str, params: list[Any] | None = None) -> list[Any]:
    return self.conn.execute(sql, params).fetchall()  # ç›´æ¥ä½¿ç”¨å…±äº«è¿æ¥
```

**å…³é”®ç‰¹å¾**ï¼š

* **æ²¡æœ‰é”ä¿æŠ¤**

* ä½¿ç”¨ `asyncio.to_thread` å°†åŒæ­¥æ•°æ®åº“æ“ä½œæ”¾åˆ°çº¿ç¨‹æ± æ‰§è¡Œ

* ç›´æ¥è®¿é—®å…±äº«çš„ `self.conn`

## ä¸‰ã€æ½œåœ¨å¹¶å‘é—®é¢˜

### é—®é¢˜ 1: DuckDB è¿æ¥çš„çº¿ç¨‹å®‰å…¨æ€§ âš ï¸ **ä¸¥é‡**

**DuckDB Python è¿æ¥å¯¹è±¡ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„**ã€‚æ ¹æ® DuckDB å®˜æ–¹æ–‡æ¡£ï¼š

> A single connection object should not be accessed from multiple threads simultaneously.

å½“å‰ä»£ç çš„é—®é¢˜ï¼š

```
æ—¶é—´çº¿:
T1: æŸ¥è¯¢A é€šè¿‡ asyncio.to_thread åœ¨çº¿ç¨‹æ± çº¿ç¨‹1 æ‰§è¡Œ conn.execute()
T2: æŸ¥è¯¢B é€šè¿‡ asyncio.to_thread åœ¨çº¿ç¨‹æ± çº¿ç¨‹2 æ‰§è¡Œ conn.execute()  â† ç«æ€æ¡ä»¶!
T3: å¯¼å…¥æ“ä½œ é€šè¿‡ asyncio.to_thread åœ¨çº¿ç¨‹æ± çº¿ç¨‹3 æ‰§è¡Œ conn.begin()
```

**åæœ**ï¼š

* æŸ¥è¯¢ç»“æœæ··ä¹±æˆ–ä¸¢å¤±

* è¿æ¥çŠ¶æ€ä¸ä¸€è‡´

* å¯èƒ½å¯¼è‡´ç¨‹åºå´©æºƒæˆ–æ•°æ®æŸå

### é—®é¢˜ 2: å¯¼å…¥ä¸æŸ¥è¯¢çš„å¹¶å‘ âš ï¸ **ä¸­ç­‰**

å¯¼å…¥é”åªä¿æŠ¤å¯¼å…¥æ“ä½œä¹‹é—´ä¸å†²çªï¼Œä½†**ä¸ä¿æŠ¤å¯¼å…¥ä¸æŸ¥è¯¢ä¹‹é—´**ï¼š

```python
# å¯¼å…¥æ“ä½œæŒæœ‰ _import_lock
async with self._import_lock:
    self.conn.begin()          # å¼€å§‹äº‹åŠ¡
    # å†™å…¥æ•°æ®...
    
    # æ­¤æ—¶æŸ¥è¯¢æ“ä½œå¯èƒ½å¹¶å‘æ‰§è¡Œï¼š
    # æŸ¥è¯¢A: self.conn.execute("SELECT ...")  â† è¯»å–åˆ°äº‹åŠ¡ä¸­é—´çŠ¶æ€?
```

**DuckDB çš„ MVCC ç‰¹æ€§**ï¼š

* DuckDB æ”¯æŒ MVCCï¼ˆå¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶ï¼‰

* è¯»æ“ä½œä¸ä¼šé˜»å¡å†™æ“ä½œ

* ä½†ç”±äº**å…±äº«å•ä¸€è¿æ¥**ï¼ŒMVCC æ— æ³•æ­£å¸¸å·¥ä½œ

### é—®é¢˜ 3: å¤šä¸ªæŸ¥è¯¢å¹¶å‘ âš ï¸ **ä¸¥é‡**

```
æŸ¥è¯¢A: await asyncio.to_thread(lambda: conn.execute(sql1))
æŸ¥è¯¢B: await asyncio.to_thread(lambda: conn.execute(sql2))
æŸ¥è¯¢C: await asyncio.to_thread(lambda: conn.execute(sql3))
```

ä¸‰ä¸ªæŸ¥è¯¢åŒæ—¶æäº¤åˆ°çº¿ç¨‹æ± ï¼Œ**å…±äº«åŒä¸€ä¸ªè¿æ¥å¯¹è±¡**ï¼Œè¿å DuckDB çš„çº¿ç¨‹å®‰å…¨è¦æ±‚ã€‚

## å››ã€ç»“è®º

| åœºæ™¯      | æ˜¯å¦å®‰å…¨  | é£é™©ç­‰çº§    |
| ------- | ----- | ------- |
| å•ä¸ªæŸ¥è¯¢    | âœ… å®‰å…¨  | æ—        |
| å¤šä¸ªæŸ¥è¯¢å¹¶å‘  | âŒ ä¸å®‰å…¨ | ğŸ”´ é«˜    |
| å¯¼å…¥ä¸æŸ¥è¯¢å¹¶å‘ | âŒ ä¸å®‰å…¨ | ğŸ”´ é«˜    |
| å¤šä¸ªå¯¼å…¥å¹¶å‘  | âœ… å®‰å…¨  | æ— ï¼ˆæœ‰é”ä¿æŠ¤ï¼‰ |

**æ ¸å¿ƒé—®é¢˜**ï¼šDuckDB Python è¿æ¥å¯¹è±¡ä¸æ”¯æŒå¤šçº¿ç¨‹å¹¶å‘è®¿é—®ï¼Œå½“å‰æ¶æ„ä½¿ç”¨å•ä¸€è¿æ¥ + `asyncio.to_thread` ä¼šå¯¼è‡´ç«æ€æ¡ä»¶ã€‚

## äº”ã€è§£å†³æ–¹æ¡ˆå»ºè®®

### æ–¹æ¡ˆ A: è¿æ¥æ± æ¨¡å¼ï¼ˆæ¨èï¼‰

ä¸ºæ¯ä¸ªçº¿ç¨‹åˆ›å»ºç‹¬ç«‹çš„è¿æ¥ï¼š

```python
from threading import local

class DBMixin(BaseEngine):
    def __init__(self, *args, **kwargs) -> None:
        self._thread_local = local()
    
    @property
    def conn(self) -> duckdb.DuckDBPyConnection:
        if not hasattr(self._thread_local, 'conn') or self._thread_local.conn is None:
            self._thread_local.conn = self._create_connection()
        return self._thread_local.conn
```

**ä¼˜ç‚¹**ï¼šæ¯ä¸ªçº¿ç¨‹æœ‰ç‹¬ç«‹è¿æ¥ï¼Œé¿å…ç«æ€æ¡ä»¶
**ç¼ºç‚¹**ï¼šå†…å­˜æ¨¡å¼ä¸‹çš„æ•°æ®ä¸å…±äº«ï¼ˆéœ€è¦æ”¹ç”¨æ–‡ä»¶æ¨¡å¼æˆ–å…¶ä»–æ–¹æ¡ˆï¼‰

### æ–¹æ¡ˆ B: å…¨å±€æ•°æ®åº“é”

ä¸ºæ‰€æœ‰æ•°æ®åº“æ“ä½œæ·»åŠ å…¨å±€é”ï¼š

```python
class DBMixin(BaseEngine):
    def __init__(self, *args, **kwargs) -> None:
        self._db_lock = asyncio.Lock()
    
    async def execute_query(self, sql: str, params=None):
        async with self._db_lock:
            return await asyncio.to_thread(self._execute_query_sync, sql, params)
```

**ä¼˜ç‚¹**ï¼šç®€å•ï¼Œä¸éœ€è¦æ”¹å˜ç°æœ‰æ¶æ„
**ç¼ºç‚¹**ï¼šæ‰€æœ‰æ“ä½œä¸²è¡Œæ‰§è¡Œï¼Œæ€§èƒ½ä¸‹é™

### æ–¹æ¡ˆ C: è¯»å†™åˆ†ç¦» + æ–‡ä»¶æ¨¡å¼

#### æ ¸å¿ƒæ€è·¯

å°† DuckDB ä»**å†…å­˜æ¨¡å¼**æ”¹ä¸º**æ–‡ä»¶æ¨¡å¼**ï¼Œåˆ©ç”¨ DuckDB çš„ MVCC ç‰¹æ€§å®ç°çœŸæ­£çš„å¹¶å‘è¯»å†™ï¼š

* **è¯»æ“ä½œ**ï¼šä½¿ç”¨åªè¯»è¿æ¥ï¼ˆ`access_mode='read_only'`ï¼‰ï¼Œå¯å¤šè¿æ¥å¹¶å‘

* **å†™æ“ä½œ**ï¼šä½¿ç”¨ç‹¬å è¿æ¥ï¼Œç¡®ä¿å†™å…¥ä¸€è‡´æ€§

#### æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Engine å®ä¾‹                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   å†™è¿æ¥æ±        â”‚     â”‚       è¯»è¿æ¥æ±               â”‚   â”‚
â”‚  â”‚  (ç‹¬å æ¨¡å¼)      â”‚     â”‚     (åªè¯»æ¨¡å¼)              â”‚   â”‚
â”‚  â”‚                 â”‚     â”‚                             â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ writer_connâ”‚  â”‚     â”‚  â”‚ r1  â”‚ â”‚ r2  â”‚ â”‚ r3  â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚  â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚           â”‚                          â”‚                      â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                      â–¼                                      â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚              â”‚  kb.db æ–‡ä»¶   â”‚                               â”‚
â”‚              â”‚  (æŒä¹…åŒ–å­˜å‚¨)  â”‚                               â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å®ç°ä»£ç 

**1. ä¿®æ”¹ DBMixin æ”¯æŒè¯»å†™åˆ†ç¦»**

```python
# db.py
import duckdb
from threading import Lock
from contextlib import contextmanager
from duckkb.core.base import BaseEngine
from duckkb.logger import logger


class DBMixin(BaseEngine):
    """æ•°æ®åº“è¿æ¥ç®¡ç† Mixinï¼ˆè¯»å†™åˆ†ç¦»ç‰ˆï¼‰ã€‚

    ä½¿ç”¨æ–‡ä»¶æ¨¡å¼ DuckDBï¼Œæ”¯æŒï¼š
    - å¤šä¸ªåªè¯»è¿æ¥å¹¶å‘è¯»å–
    - å•ä¸€å†™è¿æ¥ç‹¬å å†™å…¥
    - MVCC ä¿è¯è¯»å†™ä¸é˜»å¡
    """

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._writer_conn: duckdb.DuckDBPyConnection | None = None
        self._reader_conns: list[duckdb.DuckDBPyConnection] = []
        self._writer_lock = Lock()  # ä¿æŠ¤å†™è¿æ¥
        self._db_path: Path | None = None

    def _get_db_path(self) -> Path:
        """è·å–æ•°æ®åº“æ–‡ä»¶è·¯å¾„ã€‚"""
        if self._db_path is None:
            self._db_path = self.kb_path / "kb.db"
        return self._db_path

    @property
    def conn(self) -> duckdb.DuckDBPyConnection:
        """è·å–å†™è¿æ¥ï¼ˆå‘åå…¼å®¹ï¼‰ã€‚"""
        return self.writer_conn

    @property
    def writer_conn(self) -> duckdb.DuckDBPyConnection:
        """è·å–å†™è¿æ¥ï¼ˆç‹¬å æ¨¡å¼ï¼‰ã€‚"""
        if self._writer_conn is None:
            db_path = self._get_db_path()
            self._writer_conn = duckdb.connect(str(db_path))
            logger.debug(f"Writer connection established: {db_path}")
        return self._writer_conn

    def get_reader_conn(self) -> duckdb.DuckDBPyConnection:
        """è·å–åªè¯»è¿æ¥ã€‚

        æ¯æ¬¡è°ƒç”¨è¿”å›ä¸€ä¸ªæ–°çš„åªè¯»è¿æ¥ï¼Œ
        è°ƒç”¨è€…è´Ÿè´£åœ¨ä½¿ç”¨å®Œæ¯•åå…³é—­è¿æ¥ã€‚
        """
        db_path = self._get_db_path()
        conn = duckdb.connect(str(db_path), read_only=True)
        logger.debug(f"Reader connection established: {db_path}")
        return conn

    @contextmanager
    def reader(self):
        """åªè¯»è¿æ¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ã€‚

        ç”¨æ³•ï¼š
            with engine.reader() as conn:
                result = conn.execute("SELECT ...").fetchall()
        """
        conn = self.get_reader_conn()
        try:
            yield conn
        finally:
            conn.close()

    def close(self) -> None:
        """å…³é—­æ‰€æœ‰è¿æ¥ã€‚"""
        if self._writer_conn is not None:
            self._writer_conn.close()
            self._writer_conn = None
            logger.debug("Writer connection closed")

        for conn in self._reader_conns:
            try:
                conn.close()
            except Exception:
                pass
        self._reader_conns.clear()
        logger.debug("All reader connections closed")
```

**2. ä¿®æ”¹ SearchMixin ä½¿ç”¨åªè¯»è¿æ¥**

```python
# search.py
class SearchMixin(BaseEngine):
    """æ£€ç´¢èƒ½åŠ› Mixinï¼ˆè¯»å†™åˆ†ç¦»ç‰ˆï¼‰ã€‚"""

    async def search(self, query: str, ...) -> list[dict[str, Any]]:
        """æ™ºèƒ½æ··åˆæœç´¢ï¼ˆä½¿ç”¨åªè¯»è¿æ¥ï¼‰ã€‚"""
        if not query:
            return []

        query_vector = await self._get_query_vector(query)
        if not query_vector:
            return []

        return await self._execute_hybrid_search_readonly(
            query=query,
            query_vector=query_vector,
            node_type=node_type,
            limit=limit,
            alpha=alpha,
        )

    async def _execute_hybrid_search_readonly(
        self,
        query: str,
        query_vector: list[float],
        node_type: str | None,
        limit: int,
        alpha: float,
    ) -> list[dict[str, Any]]:
        """ä½¿ç”¨åªè¯»è¿æ¥æ‰§è¡Œæ··åˆæ£€ç´¢ã€‚"""

        def _execute() -> list[dict[str, Any]]:
            with self.reader() as conn:  # ä½¿ç”¨åªè¯»è¿æ¥
                rows = conn.execute(sql, params).fetchall()
                return self._process_results(rows)

        return await asyncio.to_thread(_execute)

    async def vector_search(self, query: str, ...) -> list[dict[str, Any]]:
        """çº¯å‘é‡æ£€ç´¢ï¼ˆä½¿ç”¨åªè¯»è¿æ¥ï¼‰ã€‚"""

        def _execute():
            with self.reader() as conn:
                return conn.execute(sql, params).fetchall()

        return await asyncio.to_thread(_execute)

    async def fts_search(self, query: str, ...) -> list[dict[str, Any]]:
        """çº¯å…¨æ–‡æ£€ç´¢ï¼ˆä½¿ç”¨åªè¯»è¿æ¥ï¼‰ã€‚"""

        def _execute():
            with self.reader() as conn:
                return conn.execute(sql, params).fetchall()

        return await asyncio.to_thread(_execute)

    async def get_source_record(
        self,
        source_table: str,
        source_id: int,
    ) -> dict[str, Any] | None:
        """å›æåŸå§‹è®°å½•ï¼ˆä½¿ç”¨åªè¯»è¿æ¥ï¼‰ã€‚"""
        validate_table_name(source_table)

        def _fetch() -> dict[str, Any] | None:
            with self.reader() as conn:
                row = conn.execute(
                    f"SELECT * FROM {source_table} WHERE __id = ?",
                    [source_id],
                ).fetchone()
                if not row:
                    return None
                cursor = conn.execute(f"SELECT * FROM {source_table} LIMIT 0")
                columns = [desc[0] for desc in cursor.description]
                return dict(zip(columns, row))

        return await asyncio.to_thread(_fetch)
```

**3. ä¿®æ”¹ ImportMixin ä½¿ç”¨å†™è¿æ¥**

```python
# import_.py
class ImportMixin(BaseEngine):
    """çŸ¥è¯†å¯¼å…¥èƒ½åŠ› Mixinï¼ˆè¯»å†™åˆ†ç¦»ç‰ˆï¼‰ã€‚"""

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._import_lock = asyncio.Lock()

    async def import_knowledge_bundle(self, temp_file_path: str) -> dict[str, Any]:
        """å¯¼å…¥çŸ¥è¯†åŒ…ï¼ˆä½¿ç”¨å†™è¿æ¥ï¼‰ã€‚"""
        async with self._import_lock:
            # ... çœç•¥æ ¡éªŒé€»è¾‘ ...

            # ä½¿ç”¨ writer_conn æ‰§è¡Œå†™å…¥
            result = await self._execute_import_in_transaction(nodes_data, edges_data)
            # ...

    async def _execute_import_in_transaction(
        self,
        nodes_data: list[dict[str, Any]],
        edges_data: list[dict[str, Any]],
    ) -> dict[str, Any]:
        """åœ¨äº‹åŠ¡ä¸­æ‰§è¡Œå¯¼å…¥ï¼ˆä½¿ç”¨å†™è¿æ¥ï¼‰ã€‚"""

        def _execute() -> dict[str, Any]:
            with self._writer_lock:  # çº¿ç¨‹å®‰å…¨ä¿æŠ¤
                try:
                    self.writer_conn.begin()
                    # ... å¯¼å…¥é€»è¾‘ ...
                    self.writer_conn.commit()
                    return result
                except Exception as e:
                    self.writer_conn.rollback()
                    raise

        return await asyncio.to_thread(_execute)
```

#### æ•°æ®æŒä¹…åŒ–ç­–ç•¥

æ–‡ä»¶æ¨¡å¼ä¸‹éœ€è¦è°ƒæ•´æŒä¹…åŒ–ç­–ç•¥ï¼š

```python
# engine.py
class Engine(...):
    async def _load_existing_data(self) -> None:
        """ä»æ•°æ®åº“æ–‡ä»¶åŠ è½½å·²æœ‰æ•°æ®ã€‚

        æ–‡ä»¶æ¨¡å¼ä¸‹ï¼Œæ•°æ®å·²æŒä¹…åŒ–åˆ° kb.dbï¼Œ
        æ— éœ€ä» JSONL é‡æ–°åŠ è½½ã€‚
        """
        db_path = self.kb_path / "kb.db"
        if db_path.exists():
            logger.info(f"Database file exists: {db_path}")
            # æ•°æ®å·²åœ¨æ•°æ®åº“ä¸­ï¼Œæ— éœ€é¢å¤–åŠ è½½
            return

        # é¦–æ¬¡å¯åŠ¨ï¼šä» JSONL å¯¼å…¥å†å²æ•°æ®
        await self._import_from_jsonl()

    async def _import_from_jsonl(self) -> None:
        """ä» JSONL æ–‡ä»¶å¯¼å…¥å†å²æ•°æ®åˆ°æ•°æ®åº“ã€‚"""
        data_dir = self.config.storage.data_dir
        if not data_dir.exists():
            return

        # å¯¼å…¥èŠ‚ç‚¹
        for node_type in self.ontology.nodes.keys():
            await self.load_node(node_type)

        # å¯¼å…¥è¾¹
        for edge_name in self.ontology.edges.keys():
            await self.load_edge(edge_name)
```

#### é…ç½®å˜æ›´

```yaml
# config.yaml
global:
  # æ–°å¢ï¼šæ•°æ®åº“æ¨¡å¼é…ç½®
  database:
    mode: "file"           # "memory" | "file"
    path: "kb.db"          # ç›¸å¯¹äº kb_path
    wal_mode: true         # å¯ç”¨ WAL æ¨¡å¼æå‡å¹¶å‘æ€§èƒ½

storage:
  data_dir: "data"         # JSONL å¯¼å‡ºç›®å½•ï¼ˆå¤‡ä»½ç”¨ï¼‰
  partition_by_date: true
```

#### æ€§èƒ½ä¼˜åŒ–é€‰é¡¹

```python
# å¯ç”¨ WAL æ¨¡å¼æå‡å¹¶å‘æ€§èƒ½
def _create_writer_conn(self) -> duckdb.DuckDBPyConnection:
    conn = duckdb.connect(str(self._get_db_path()))
    conn.execute("PRAGMA wal_mode='true'")  # å¯ç”¨ WAL
    conn.execute("PRAGMA threads=4")        # å¹¶è¡ŒæŸ¥è¯¢
    return conn
```

#### ä¼˜ç¼ºç‚¹åˆ†æ

| æ–¹é¢       | ä¼˜ç‚¹             | ç¼ºç‚¹            |
| -------- | -------------- | ------------- |
| **å¹¶å‘æ€§èƒ½** | è¯»æ“ä½œçœŸæ­£å¹¶å‘ï¼Œä¸é˜»å¡å†™æ“ä½œ | å†™æ“ä½œä»éœ€ç‹¬å        |
| **æ•°æ®å®‰å…¨** | æ•°æ®æŒä¹…åŒ–åˆ°æ–‡ä»¶ï¼Œå´©æºƒä¸ä¸¢å¤± | éœ€è¦ç®¡ç†æ–‡ä»¶        |
| **å†…å­˜å ç”¨** | æ•°æ®ä¸å¸¸é©»å†…å­˜ï¼ŒæŒ‰éœ€åŠ è½½   | é¢‘ç¹è®¿é—®å¯èƒ½æœ‰ IO å¼€é”€ |
| **å…¼å®¹æ€§**  | éœ€è¦ä¿®æ”¹ç°æœ‰æ¶æ„       | è¿ç§»æˆæœ¬ä¸­ç­‰        |

#### å¯¼å…¥å¹¶å‘åˆ†æ

**é—®é¢˜**ï¼šæ–¹æ¡ˆ C æ˜¯å¦å¯ä»¥å»æ‰å¯¼å…¥é”ï¼Œæ”¯æŒå¤šä¸ªå¯¼å…¥åŒæ—¶è¿›è¡Œï¼Ÿ

**ç­”æ¡ˆ**ï¼šâŒ **ä¸å¯ä»¥**ï¼Œå¯¼å…¥é”ä»ç„¶éœ€è¦ä¿ç•™ã€‚

**åŸå› **ï¼šDuckDB çš„å†™å…¥å¹¶å‘é™åˆ¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DuckDB å†™å…¥é™åˆ¶                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  âœ… å¤šä¸ªåªè¯»è¿æ¥å¯ä»¥å¹¶å‘è¯»å–                                  â”‚
â”‚  âœ… è¯»æ“ä½œä¸é˜»å¡å†™æ“ä½œï¼ˆMVCCï¼‰                                â”‚
â”‚  âŒ åªæ”¯æŒå•ä¸€å†™å…¥è€…                                         â”‚
â”‚  âŒ å†™è¿æ¥å¯¹è±¡æœ¬èº«ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„                              â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å…·ä½“é—®é¢˜**ï¼š

```python
# å‡è®¾å»æ‰å¯¼å…¥é”ï¼Œä¸¤ä¸ªå¯¼å…¥åŒæ—¶æ‰§è¡Œï¼š

# å¯¼å…¥A: åœ¨çº¿ç¨‹1
writer_conn.begin()        # å¼€å§‹äº‹åŠ¡A
writer_conn.execute(...)   # å†™å…¥æ•°æ®A

# å¯¼å…¥B: åœ¨çº¿ç¨‹2ï¼ˆåŒæ—¶ï¼‰
writer_conn.begin()        # â† é”™è¯¯ï¼è¿æ¥å·²åœ¨äº‹åŠ¡Aä¸­
writer_conn.execute(...)   # â† ç«æ€æ¡ä»¶ï¼
```

å³ä½¿åªæœ‰ä¸€ä¸ª `writer_conn`ï¼Œ**å¤šä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨åŒä¸€ä¸ªè¿æ¥çš„æ–¹æ³•**ä»ç„¶ä¼šå¯¼è‡´ï¼š

* äº‹åŠ¡çŠ¶æ€æ··ä¹±

* æ•°æ®ä¸ä¸€è‡´

* è¿æ¥å´©æºƒ

**æ­£ç¡®åšæ³•**ï¼šä¿ç•™é”ï¼Œä¸²è¡ŒåŒ–å†™å…¥æ“ä½œ

```python
class ImportMixin(BaseEngine):
    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._import_lock = asyncio.Lock()  # å¿…é¡»ä¿ç•™ï¼

    async def import_knowledge_bundle(self, temp_file_path: str) -> dict[str, Any]:
        async with self._import_lock:  # ä¸²è¡ŒåŒ–å¯¼å…¥
            # ä½¿ç”¨ writer_conn æ‰§è¡Œå†™å…¥
            ...
```

**å¹¶å‘èƒ½åŠ›æ€»ç»“**ï¼š

| æ“ä½œç»„åˆ    | æ˜¯å¦æ”¯æŒå¹¶å‘ | åŸå›              |
| ------- | ------ | -------------- |
| å¤šä¸ªæŸ¥è¯¢    | âœ… æ”¯æŒ   | åªè¯»è¿æ¥å¯å¤šè¿æ¥å¹¶å‘     |
| å¯¼å…¥ + æŸ¥è¯¢ | âœ… æ”¯æŒ   | è¯»å†™åˆ†ç¦»ï¼ŒMVCC ä¸é˜»å¡  |
| å¤šä¸ªå¯¼å…¥    | âŒ ä¸æ”¯æŒ  | DuckDB å•ä¸€å†™å…¥è€…é™åˆ¶ |

**å¦‚æœéœ€è¦å¤šä¸ªå¯¼å…¥å¹¶å‘**ï¼Œæœ‰ä»¥ä¸‹æ›¿ä»£æ–¹æ¡ˆï¼š

##### æ–¹æ¡ˆ 1: å¯¼å…¥é˜Ÿåˆ—ï¼ˆæ¨èï¼‰

å°†å¯¼å…¥è¯·æ±‚æ”¾å…¥é˜Ÿåˆ—ï¼Œç”±å•ä¸€æ¶ˆè´¹è€…å¤„ç†ï¼š

```python
class ImportMixin(BaseEngine):
    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._import_queue: asyncio.Queue = asyncio.Queue()
        self._import_task: asyncio.Task | None = None

    async def start_import_worker(self) -> None:
        """å¯åŠ¨å¯¼å…¥å·¥ä½œåç¨‹ã€‚"""
        self._import_task = asyncio.create_task(self._import_worker())

    async def _import_worker(self) -> None:
        """å¯¼å…¥å·¥ä½œåç¨‹ï¼Œä¸²è¡Œå¤„ç†å¯¼å…¥è¯·æ±‚ã€‚"""
        while True:
            request = await self._import_queue.get()
            try:
                await self._do_import(request)
            except Exception as e:
                logger.error(f"Import failed: {e}")
            finally:
                self._import_queue.task_done()

    async def import_knowledge_bundle(self, temp_file_path: str) -> dict[str, Any]:
        """æäº¤å¯¼å…¥è¯·æ±‚åˆ°é˜Ÿåˆ—ã€‚"""
        future = asyncio.Future()
        await self._import_queue.put((temp_file_path, future))
        return await future  # ç­‰å¾…å®Œæˆ
```

**ä¼˜ç‚¹**ï¼š

* è°ƒç”¨æ–¹æ— éœ€ç­‰å¾…é”ï¼Œç›´æ¥æäº¤åˆ°é˜Ÿåˆ—

* å¯¼å…¥æ“ä½œè‡ªåŠ¨ä¸²è¡ŒåŒ–

* å¯ä»¥æ·»åŠ ä¼˜å…ˆçº§ã€é‡è¯•ç­‰é«˜çº§åŠŸèƒ½

##### æ–¹æ¡ˆ 2: æ‰¹é‡åˆå¹¶å¯¼å…¥

å°†å¤šä¸ªå°å¯¼å…¥åˆå¹¶ä¸ºä¸€ä¸ªå¤§å¯¼å…¥ï¼š

```python
async def batch_import(self, requests: list[ImportRequest]) -> dict:
    """æ‰¹é‡å¯¼å…¥ï¼Œåœ¨å•ä¸€äº‹åŠ¡ä¸­å®Œæˆã€‚"""
    async with self._import_lock:
        self.writer_conn.begin()
        try:
            for req in requests:
                await self._do_import_single(req)
            self.writer_conn.commit()
        except Exception:
            self.writer_conn.rollback()
            raise
```

##### æ–¹æ¡ˆ 3: åˆ†ç‰‡å†™å…¥ï¼ˆé«˜çº§ï¼‰

å¦‚æœæ•°æ®é‡å¤§ï¼Œå¯ä»¥æŒ‰èŠ‚ç‚¹ç±»å‹åˆ†ç‰‡å†™å…¥ï¼š

```python
# ä¸åŒèŠ‚ç‚¹ç±»å‹çš„å¯¼å…¥å¯ä»¥å¹¶å‘ï¼ˆå› ä¸ºå†™å…¥ä¸åŒçš„è¡¨ï¼‰
# ä½†ä»éœ€æ³¨æ„ DuckDB çš„å•ä¸€å†™å…¥è€…é™åˆ¶
```

**æ³¨æ„**ï¼šè¿™ä¸ªæ–¹æ¡ˆä»ç„¶å—é™äº DuckDB çš„å•ä¸€å†™å…¥è€…é™åˆ¶ï¼Œå®é™…æ•ˆæœæœ‰é™ã€‚

#### è¿ç§»æ­¥éª¤

1. **æ·»åŠ é…ç½®é¡¹**ï¼šåœ¨ `config.yaml` ä¸­æ·»åŠ  `database.mode` é…ç½®
2. **ä¿®æ”¹ DBMixin**ï¼šå®ç°è¯»å†™åˆ†ç¦»è¿æ¥ç®¡ç†
3. **ä¿®æ”¹ SearchMixin**ï¼šä½¿ç”¨ `reader()` ä¸Šä¸‹æ–‡ç®¡ç†å™¨
4. **ä¿®æ”¹ ImportMixin**ï¼šä½¿ç”¨ `writer_conn` å’Œé”ä¿æŠ¤ï¼ˆ**é”å¿…é¡»ä¿ç•™**ï¼‰
5. **æ›´æ–°æµ‹è¯•**ï¼šæ·»åŠ å¹¶å‘æµ‹è¯•ç”¨ä¾‹éªŒè¯
6. **æ•°æ®è¿ç§»**ï¼šæä¾›ä»å†…å­˜æ¨¡å¼åˆ°æ–‡ä»¶æ¨¡å¼çš„è¿ç§»è„šæœ¬

### æ–¹æ¡ˆ D: å•çº¿ç¨‹æ‰§è¡Œå™¨

æ‰€æœ‰æ•°æ®åº“æ“ä½œéƒ½åœ¨å•ä¸€äº‹ä»¶å¾ªç¯çº¿ç¨‹æ‰§è¡Œï¼Œä¸ä½¿ç”¨ `asyncio.to_thread`ï¼š

```python
# ä½¿ç”¨ DuckDB çš„å¼‚æ­¥ APIï¼ˆå¦‚æœæ”¯æŒï¼‰
# æˆ–ä½¿ç”¨ run_in_executor ä½†é™åˆ¶ä¸ºå•çº¿ç¨‹æ‰§è¡Œå™¨
```

**ä¼˜ç‚¹**ï¼šé¿å…å¤šçº¿ç¨‹é—®é¢˜
**ç¼ºç‚¹**ï¼šå¯èƒ½å½±å“å¼‚æ­¥æ€§èƒ½

## å…­ã€æ¨èå®æ–½è·¯å¾„

1. **çŸ­æœŸä¿®å¤**ï¼šé‡‡ç”¨æ–¹æ¡ˆ Bï¼ˆå…¨å±€æ•°æ®åº“é”ï¼‰ï¼Œç¡®ä¿æ•°æ®å®‰å…¨
2. **ä¸­æœŸä¼˜åŒ–**ï¼šè¯„ä¼°æ–¹æ¡ˆ A æˆ– Cï¼Œæ ¹æ®æ€§èƒ½éœ€æ±‚é€‰æ‹©
3. **é•¿æœŸè§„åˆ’**ï¼šè€ƒè™‘å¼•å…¥çœŸæ­£çš„å¼‚æ­¥æ•°æ®åº“é©±åŠ¨æˆ–è¿æ¥æ± 

## ä¸ƒã€æµ‹è¯•å»ºè®®

æ·»åŠ å¹¶å‘æµ‹è¯•ç”¨ä¾‹éªŒè¯ä¿®å¤æ•ˆæœï¼š

```python
async def test_concurrent_queries():
    tasks = [engine.search(f"query_{i}") for i in range(10)]
    results = await asyncio.gather(*tasks)
    # éªŒè¯ç»“æœæ­£ç¡®æ€§

async def test_import_and_query_concurrent():
    import_task = engine.import_knowledge_bundle(temp_file)
    query_tasks = [engine.search(f"query_{i}") for i in range(5)]
    await asyncio.gather(import_task, *query_tasks)
    # éªŒè¯æ•°æ®ä¸€è‡´æ€§
```

