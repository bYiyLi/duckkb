# DuckKB 知识图谱检索设计方案

## 1. 背景分析

### 1.1 现有检索能力

| 检索类型   | 实现方式                      | 适用场景     |
| ------ | ------------------------- | -------- |
| 向量检索   | `array_cosine_similarity` | 语义相似性查询  |
| 全文检索   | `fts_match`               | 关键词精确匹配  |
| 混合检索   | RRF 融合                    | 综合语义+关键词 |
| SQL 查询 | `query_raw_sql`           | 结构化数据查询  |

### 1.2 现有数据模型

**节点表结构**：

```sql
CREATE TABLE {node_table} (
    __id BIGINT PRIMARY KEY,
    __created_at TIMESTAMP,
    __updated_at TIMESTAMP,
    __date DATE,
    -- 业务字段根据 json_schema 定义
);
```

**边表结构**：

```sql
CREATE TABLE edge_{edge_name} (
    __id BIGINT PRIMARY KEY,
    __from_id BIGINT NOT NULL,  -- 起始节点 ID
    __to_id BIGINT NOT NULL,    -- 目标节点 ID
    __created_at TIMESTAMP,
    __updated_at TIMESTAMP,
    __date DATE,
    -- 边属性根据 json_schema 定义
);
```

### 1.3 设计约束

1. **存储引擎**：DuckDB 是关系型数据库，非原生图数据库
2. **性能要求**：需利用 DuckDB 的列式存储和向量化执行优势
3. **兼容性**：需与现有 Mixin 架构无缝集成
4. **MCP 暴露**：需提供清晰的 AI Agent 调用接口

***

## 2. 知识图谱检索能力设计

### 2.1 核心检索模式

```
┌─────────────────────────────────────────────────────────────────┐
│                     知识图谱检索能力矩阵                           │
├─────────────────┬───────────────────────────────────────────────┤
│  邻居查询        │  获取节点的直接关联节点（一跳）                    │
├─────────────────┼───────────────────────────────────────────────┤
│  多跳遍历        │  沿指定边类型进行 N 跳遍历                        │
├─────────────────┼───────────────────────────────────────────────┤
│  路径查询        │  查找两个节点之间的最短路径                       │
├─────────────────┼───────────────────────────────────────────────┤
│  子图提取        │  提取与指定节点相关的完整子图                      │
├─────────────────┼───────────────────────────────────────────────┤
│  图谱+向量融合   │  向量检索结果作为起点，进行图遍历扩展               │
└─────────────────┴───────────────────────────────────────────────┘
```

### 2.2 API 设计

#### 2.2.1 邻居查询 `get_neighbors`

获取节点的直接邻居，支持方向过滤和边类型过滤。

```python
async def get_neighbors(
    self,
    node_type: str,
    node_id: int | str,
    *,
    edge_types: list[str] | None = None,  # 边类型过滤
    direction: str = "both",               # "out" | "in" | "both"
    limit: int = 100,
) -> dict[str, Any]:
    """获取节点的邻居节点。

    Args:
        node_type: 起始节点类型。
        node_id: 起始节点 ID 或 identity 字段值。
        edge_types: 边类型过滤列表，None 表示所有边。
        direction: 遍历方向，"out" 出边，"in" 入边，"both" 双向。
        limit: 每种边类型返回的最大邻居数。

    Returns:
        {
            "node": {...},           # 起始节点信息
            "neighbors": [
                {
                    "edge_type": "located_at",
                    "direction": "out",
                    "edge": {...},    # 边属性
                    "node": {...}     # 邻居节点
                },
                ...
            ]
        }
    """
```

#### 2.2.2 多跳遍历 `traverse`

沿指定边类型进行多跳遍历，支持深度限制和方向控制。

```python
async def traverse(
    self,
    node_type: str,
    node_id: int | str,
    *,
    edge_types: list[str] | None = None,
    direction: str = "out",
    max_depth: int = 3,
    limit: int = 1000,
) -> list[dict[str, Any]]:
    """多跳图遍历。

    Args:
        node_type: 起始节点类型。
        node_id: 起始节点 ID。
        edge_types: 允许的边类型列表。
        direction: 遍历方向。
        max_depth: 最大遍历深度。
        limit: 返回节点总数限制。

    Returns:
        遍历路径列表，每条路径包含节点和边信息：
        [
            {
                "path": [node1, edge1, node2, edge2, node3],
                "depth": 2,
                "nodes": [node1, node2, node3],
                "edges": [edge1, edge2]
            },
            ...
        ]
    """
```

#### 2.2.3 路径查询 `find_paths`

查找两个节点之间的路径。

```python
async def find_paths(
    self,
    from_node: tuple[str, int | str],  # (node_type, node_id)
    to_node: tuple[str, int | str],
    *,
    edge_types: list[str] | None = None,
    max_depth: int = 5,
    limit: int = 10,
) -> list[dict[str, Any]]:
    """查找两节点间的路径。

    Args:
        from_node: 起始节点 (类型, ID)。
        to_node: 目标节点 (类型, ID)。
        edge_types: 允许的边类型。
        max_depth: 最大路径长度。
        limit: 返回路径数量限制。

    Returns:
        路径列表：
        [
            {
                "path": [node1, edge1, node2, edge2, node3],
                "length": 2
            },
            ...
        ]
    """
```

#### 2.2.4 子图提取 `extract_subgraph`

提取与指定节点相关的子图。

```python
async def extract_subgraph(
    self,
    node_type: str,
    node_id: int | str,
    *,
    edge_types: list[str] | None = None,
    max_depth: int = 2,
    node_limit: int = 100,
    edge_limit: int = 200,
) -> dict[str, Any]:
    """提取子图。

    Args:
        node_type: 中心节点类型。
        node_id: 中心节点 ID。
        edge_types: 包含的边类型。
        max_depth: 扩展深度。
        node_limit: 节点数量限制。
        edge_limit: 边数量限制。

    Returns:
        {
            "center_node": {...},
            "nodes": [...],    # 所有节点
            "edges": [...],    # 所有边
            "stats": {
                "node_count": 50,
                "edge_count": 80,
                "depth_reached": 2
            }
        }
    """
```

#### 2.2.5 图谱+向量融合检索 `graph_search`

向量检索结果作为起点，进行图遍历扩展，实现"语义+结构"双重检索。

```python
async def graph_search(
    self,
    query: str,
    *,
    node_type: str | None = None,
    edge_types: list[str] | None = None,
    traverse_depth: int = 1,
    search_limit: int = 5,
    neighbor_limit: int = 10,
) -> list[dict[str, Any]]:
    """向量检索 + 图遍历融合检索。

    流程：
    1. 向量检索找到语义相关的种子节点
    2. 对种子节点进行图遍历扩展
    3. 返回种子节点及其关联上下文

    Args:
        query: 查询文本。
        node_type: 种子节点类型过滤。
        edge_types: 遍历边类型过滤。
        traverse_depth: 图遍历深度。
        search_limit: 向量检索返回的种子节点数。
        neighbor_limit: 每个种子节点的邻居数限制。

    Returns:
        [
            {
                "seed": {
                    "node": {...},
                    "score": 0.85,
                    "source_field": "description"
                },
                "context": [
                    {
                        "edge_type": "located_at",
                        "direction": "out",
                        "node": {...}
                    },
                    ...
                ]
            },
            ...
        ]
    """
```

***

## 3. 实现方案

### 3.1 新增 Mixin 模块

创建 `src/duckkb/core/mixins/graph.py`，实现 `GraphMixin`：

```python
class GraphMixin(BaseEngine):
    """知识图谱检索 Mixin。

    提供基于边表的图遍历和查询能力。
    依赖 conn (DBMixin) 和 ontology (OntologyMixin)。
    """

    async def get_neighbors(...) -> dict[str, Any]:
        """获取邻居节点。"""
        pass

    async def traverse(...) -> list[dict[str, Any]]:
        """多跳遍历。"""
        pass

    async def find_paths(...) -> list[dict[str, Any]]:
        """路径查询。"""
        pass

    async def extract_subgraph(...) -> dict[str, Any]:
        """子图提取。"""
        pass

    async def graph_search(...) -> list[dict[str, Any]]:
        """向量+图谱融合检索。"""
        pass
```

### 3.2 SQL 实现策略

#### 邻居查询 SQL

```sql
-- 出边邻居
SELECT
    e.__id as edge_id,
    e.__from_id,
    e.__to_id,
    e.*,
    n.* as neighbor
FROM edge_{edge_name} e
JOIN {target_table} n ON e.__to_id = n.__id
WHERE e.__from_id = ?

-- 入边邻居
SELECT
    e.__id as edge_id,
    e.__from_id,
    e.__to_id,
    e.*,
    n.* as neighbor
FROM edge_{edge_name} e
JOIN {source_table} n ON e.__from_id = n.__id
WHERE e.__to_id = ?
```

#### 多跳遍历 SQL（递归 CTE）

```sql
WITH RECURSIVE traverse AS (
    -- 基础：起始节点
    SELECT
        __id as node_id,
        0 as depth,
        ARRAY[__id] as path_ids,
        ARRAY[]::BIGINT[] as edge_ids
    FROM {node_table}
    WHERE __id = {start_id}

    UNION ALL

    -- 递归：沿边扩展
    SELECT
        CASE
            WHEN e.__from_id = t.node_id THEN e.__to_id
            ELSE e.__from_id
        END as node_id,
        t.depth + 1,
        t.path_ids || ARRAY[e.__to_id],
        t.edge_ids || ARRAY[e.__id]
    FROM traverse t
    JOIN edge_{edge_name} e
      ON e.__from_id = t.node_id OR e.__to_id = t.node_id
    WHERE t.depth < {max_depth}
      AND NOT (t.path_ids @> ARRAY[e.__to_id])  -- 避免环
)
SELECT * FROM traverse WHERE depth > 0;
```

#### 路径查询 SQL（双向 BFS）

```sql
WITH RECURSIVE
forward AS (
    SELECT __from_id, __to_id, ARRAY[__from_id, __to_id] as path, 1 as depth
    FROM edge_{edge_name}
    WHERE __from_id = {from_id}
    UNION ALL
    SELECT e.__from_id, e.__to_id, f.path || e.__to_id, f.depth + 1
    FROM forward f
    JOIN edge_{edge_name} e ON e.__from_id = f.__to_id
    WHERE f.depth < {max_depth} AND NOT (f.path @> ARRAY[e.__to_id])
),
backward AS (
    SELECT __from_id, __to_id, ARRAY[__to_id, __from_id] as path, 1 as depth
    FROM edge_{edge_name}
    WHERE __to_id = {to_id}
    UNION ALL
    SELECT e.__from_id, e.__to_id, b.path || e.__from_id, b.depth + 1
    FROM backward b
    JOIN edge_{edge_name} e ON e.__to_id = b.__from_id
    WHERE b.depth < {max_depth} AND NOT (b.path @> ARRAY[e.__from_id])
)
SELECT * FROM forward WHERE __to_id = {to_id}
UNION ALL
SELECT * FROM backward WHERE __from_id = {from_id}
ORDER BY depth
LIMIT {limit};
```

### 3.3 Engine 集成

修改 `src/duckkb/core/engine.py`：

```python
class Engine(
    ConfigMixin,
    DBMixin,
    OntologyMixin,
    StorageMixin,
    ChunkingMixin,
    TokenizerMixin,
    EmbeddingMixin,
    IndexMixin,
    SearchMixin,
    GraphMixin,      # 新增
    ImportMixin,
):
    """知识库引擎。"""
```

### 3.4 MCP 工具暴露

修改 `src/duckkb/mcp/duck_mcp.py`，注册新工具：

```python
def _register_tools(self) -> None:
    # 现有工具...
    self._register_get_neighbors_tool()
    self._register_traverse_tool()
    self._register_find_paths_tool()
    self._register_extract_subgraph_tool()
    self._register_graph_search_tool()
```

***

## 4. 配置扩展

### 4.1 本体配置扩展

在 `config.yaml` 中为边添加索引配置：

```yaml
ontology:
  edges:
    located_at:
      from: Character
      to: Location
      cardinality: N:1
      schema:
        type: object
        properties:
          since: {type: string, format: date-time}
      # 新增：边索引配置
      index:
        from_indexed: true   # 为 __from_id 创建索引
        to_indexed: true     # 为 __to_id 创建索引
```

### 4.2 边表 DDL 增强

修改 `_generate_edge_ddl` 方法：

```python
def _generate_edge_ddl(self, edge_name: str, edge_type: EdgeType) -> str:
    columns = [...]
    
    # 添加索引
    indexes = []
    if edge_type.index and edge_type.index.from_indexed:
        indexes.append(f"CREATE INDEX IF NOT EXISTS idx_{table_name}_from ON {table_name}(__from_id);")
    if edge_type.index and edge_type.index.to_indexed:
        indexes.append(f"CREATE INDEX IF NOT EXISTS idx_{table_name}_to ON {table_name}(__to_id);")
    
    ddl = f"CREATE TABLE IF NOT EXISTS {table_name} (...);"
    return ddl + "\n" + "\n".join(indexes)
```

***

## 5. 使用示例

### 5.1 邻居查询

```python
# 查询角色的所有关联实体
result = await engine.get_neighbors(
    node_type="Character",
    node_id="char_001",
    direction="out"
)
# 返回：角色所在位置、角色所属组织等
```

### 5.2 多跳遍历

```python
# 查询角色的朋友的朋友
result = await engine.traverse(
    node_type="Character",
    node_id="char_001",
    edge_types=["friend_of"],
    max_depth=2
)
```

### 5.3 路径查询

```python
# 查询两个角色之间的关系路径
result = await engine.find_paths(
    from_node=("Character", "char_001"),
    to_node=("Character", "char_002"),
    max_depth=4
)
```

### 5.4 图谱+向量融合

```python
# 语义检索 + 图扩展
result = await engine.graph_search(
    query="勇敢的战士",
    traverse_depth=1,
    search_limit=5
)
# 返回：语义匹配的战士角色，以及他们的位置、组织等关联信息
```

### 5.5 AI Agent 调用示例

```python
# 通过 MCP 工具调用
result = await mcp.call_tool("graph_search", {
    "query": "主角的敌人",
    "traverse_depth": 2,
    "edge_types": ["enemy_of", "allied_with"]
})
```

***

## 6. 性能优化策略

### 6.1 索引策略

* 为所有边表的 `__from_id` 和 `__to_id` 创建索引

* 考虑复合索引 `(edge_type, __from_id)` 用于多边类型查询

### 6.2 查询优化

* 使用 `LIMIT` 限制遍历规模

* 使用 `EXPLAIN ANALYZE` 分析慢查询

* 对于深度遍历，考虑使用迭代式查询替代递归 CTE

### 6.3 缓存策略

* 缓存热门节点的邻居关系

* 缓存常用路径查询结果

***

## 7. 实现优先级

| 优先级 | 功能                 | 理由           |
| --- | ------------------ | ------------ |
| P0  | `get_neighbors`    | 最基础，其他功能依赖   |
| P0  | `graph_search`     | 核心价值，向量+图谱融合 |
| P1  | `traverse`         | 多跳遍历，支持复杂查询  |
| P1  | `extract_subgraph` | 子图可视化支持      |
| P2  | `find_paths`       | 路径查询，实现复杂度高  |

***

## 8. 后续扩展

### 8.1 图算法支持

* PageRank：节点重要性排序

* Community Detection：社区发现

* Centrality：中心性分析

### 8.2 图可视化

* 生成 Mermaid 图代码

* 导出 GraphML 格式

* 支持 D3.js 可视化

### 8.3 图嵌入

* Node2Vec：节点向量表示

* 图神经网络：图结构学习

