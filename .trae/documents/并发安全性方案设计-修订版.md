# DuckKB 并发安全性方案设计（修订版）

## 一、测试结论

经过 `test_duckdb_concurrency.py` 验证，得出以下结论：

### 1.1 DuckDB Python 绑定的限制

| 特性 | 是否支持 | 说明 |
|------|----------|------|
| 单一写连接 | ✅ 支持 | 基本功能正常 |
| 多个只读连接（写连接关闭后） | ✅ 支持 | 写连接关闭后可打开多个只读连接 |
| **读写连接同时存在** | ❌ **不支持** | 会抛出 `ConnectionException` |
| 多个写连接串行 | ✅ 支持 | 一个关闭后另一个可以打开 |

**关键错误**：
```
Connection Error: Can't open a connection to same database file with a different configuration than existing connections
```

### 1.2 可行方案

**单一连接 + 线程安全封装**：
- 使用单一 DuckDB 连接
- 所有数据库操作通过 `threading.Lock` 串行化
- 支持多线程/异步环境下的安全并发访问

## 二、修订后的方案设计

### 2.1 架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        Engine 实例                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              线程安全连接管理器                           │   │
│  │                                                         │   │
│  │  ┌─────────────────┐    ┌─────────────────────────┐    │   │
│  │  │  threading.Lock │───▶│   DuckDB Connection     │    │   │
│  │  │  (线程锁)        │    │   (单一连接)             │    │   │
│  │  └─────────────────┘    └─────────────────────────┘    │   │
│  │                                                         │   │
│  │  所有操作通过锁保护：                                     │   │
│  │  - execute(sql) → 查询                                   │   │
│  │  - execute_write(sql) → 写入                             │   │
│  │  - transaction() → 事务上下文管理器                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│                     ┌──────────────┐                           │
│                     │   kb.db      │                           │
│                     │  (文件模式)   │                           │
│                     └──────────────┘                           │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 核心组件设计

#### 2.2.1 数据库配置模型

```python
# src/duckkb/core/config/models.py

from typing import Literal

class DatabaseConfig(BaseModel):
    """数据库配置模型。

    Attributes:
        mode: 数据库模式，"memory" 或 "file"。
        filename: 数据库文件名，默认 "kb.db"。
        threads: 并行查询线程数，默认 4。
    """

    mode: Literal["memory", "file"] = "file"
    filename: str = "kb.db"
    threads: int = Field(default=4, ge=1, le=16)


class CoreConfig(BaseModel):
    """核心引擎配置模型。"""

    storage: StorageConfig
    global_config: GlobalConfig = Field(default_factory=GlobalConfig)
    embedding_dim: int = Field(default=1536, ge=1, le=4096)
    database: DatabaseConfig = Field(default_factory=DatabaseConfig)
```

#### 2.2.2 线程安全连接管理器

```python
# src/duckkb/core/mixins/db.py
"""数据库连接管理 Mixin（线程安全版）。"""

import threading
from contextlib import contextmanager
from pathlib import Path
from typing import Any, Generator

import duckdb

from duckkb.core.base import BaseEngine
from duckkb.logger import logger


class DBMixin(BaseEngine):
    """数据库连接管理 Mixin（线程安全版）。

    使用单一连接 + 线程锁实现并发安全：
    - 所有数据库操作通过 threading.Lock 串行化
    - 支持多线程/异步环境下的安全并发访问
    - 支持内存模式和文件模式

    注意：此方案下所有数据库操作会串行执行，但保证了线程安全。
    """

    def __init__(self, *args, **kwargs) -> None:
        """初始化数据库 Mixin。"""
        super().__init__(*args, **kwargs)
        self._conn: duckdb.DuckDBPyConnection | None = None
        self._lock = threading.Lock()
        self._db_path: Path | None = None

    @property
    def conn(self) -> duckdb.DuckDBPyConnection:
        """数据库连接（懒加载）。"""
        if self._conn is None:
            self._conn = self._create_connection()
        return self._conn

    @property
    def db_path(self) -> Path:
        """获取数据库文件路径。"""
        if self._db_path is None:
            db_config = self.config.database
            if db_config.mode == "memory":
                raise RuntimeError("Memory mode does not have a database file path")
            self._db_path = self.kb_path / db_config.filename
        return self._db_path

    @property
    def is_file_mode(self) -> bool:
        """是否为文件模式。"""
        return self.config.database.mode == "file"

    def _create_connection(self) -> duckdb.DuckDBPyConnection:
        """创建数据库连接。

        Returns:
            DuckDB 连接实例。
        """
        db_config = self.config.database

        if db_config.mode == "memory":
            conn = duckdb.connect()
            logger.debug("Database connection established (in-memory mode)")
            return conn

        # 文件模式
        self._db_path = self.kb_path / db_config.filename
        self._db_path.parent.mkdir(parents=True, exist_ok=True)

        conn = duckdb.connect(str(self._db_path))
        conn.execute(f"PRAGMA threads={db_config.threads}")

        logger.debug(f"Database connection established: {self._db_path}")
        return conn

    def execute(
        self,
        sql: str,
        params: list[Any] | None = None,
    ) -> list[tuple]:
        """执行查询（线程安全）。

        Args:
            sql: SQL 查询语句。
            params: 参数列表。

        Returns:
            查询结果列表。
        """
        with self._lock:
            if params:
                return self.conn.execute(sql, params).fetchall()
            return self.conn.execute(sql).fetchall()

    def execute_write(
        self,
        sql: str,
        params: list[Any] | None = None,
    ) -> None:
        """执行写入操作（线程安全）。

        Args:
            sql: SQL 写入语句。
            params: 参数列表。
        """
        with self._lock:
            if params:
                self.conn.execute(sql, params)
            else:
                self.conn.execute(sql)

    def executemany(
        self,
        sql: str,
        params_list: list[list[Any]],
    ) -> None:
        """批量执行操作（线程安全）。

        Args:
            sql: SQL 语句。
            params_list: 参数列表的列表。
        """
        with self._lock:
            self.conn.executemany(sql, params_list)

    @contextmanager
    def transaction(self) -> Generator[duckdb.DuckDBPyConnection, None, None]:
        """事务上下文管理器（线程安全）。

        用法：
            with engine.transaction() as conn:
                conn.execute("INSERT INTO ...")
                conn.execute("UPDATE ...")
            # 自动提交或回滚

        Yields:
            数据库连接（在事务中）。
        """
        with self._lock:
            try:
                self.conn.begin()
                yield self.conn
                self.conn.commit()
            except Exception:
                self.conn.rollback()
                raise

    def close(self) -> None:
        """关闭数据库连接。"""
        with self._lock:
            if self._conn is not None:
                self._conn.close()
                self._conn = None
                logger.debug("Database connection closed")
```

#### 2.2.3 查询操作改造

```python
# src/duckkb/core/mixins/search.py
"""检索能力 Mixin（线程安全版）。"""

import asyncio
from typing import Any

from duckkb.core.base import BaseEngine
from duckkb.exceptions import DatabaseError
from duckkb.logger import logger


class SearchMixin(BaseEngine):
    """检索能力 Mixin（线程安全版）。

    所有数据库操作通过线程安全封装执行。
    """

    async def search(
        self,
        query: str,
        *,
        node_type: str | None = None,
        limit: int = 10,
        alpha: float = 0.5,
    ) -> list[dict[str, Any]]:
        """智能混合搜索。"""
        if not query:
            return []

        query_vector = await self._get_query_vector(query)
        if not query_vector:
            logger.warning("Failed to generate query embedding")
            return []

        return await self._execute_hybrid_search(
            query=query,
            query_vector=query_vector,
            node_type=node_type,
            limit=limit,
            alpha=alpha,
        )

    async def _execute_hybrid_search(
        self,
        query: str,
        query_vector: list[float],
        node_type: str | None,
        limit: int,
        alpha: float,
    ) -> list[dict[str, Any]]:
        """执行混合检索（线程安全）。"""
        # ... SQL 构建逻辑保持不变 ...

        def _execute() -> list[Any]:
            return self.execute(sql, fts_params)  # 使用线程安全的 execute

        try:
            rows = await asyncio.to_thread(_execute)
            return self._process_results(rows)
        except Exception as e:
            logger.error(f"Hybrid search failed: {e}")
            raise DatabaseError(f"Hybrid search failed: {e}") from e

    async def get_source_record(
        self,
        source_table: str,
        source_id: int,
    ) -> dict[str, Any] | None:
        """回捞原始记录（线程安全）。"""
        validate_table_name(source_table)

        def _fetch() -> dict[str, Any] | None:
            rows = self.execute(
                f"SELECT * FROM {source_table} WHERE __id = ?",
                [source_id],
            )
            if not rows:
                return None

            cursor_rows = self.execute(f"SELECT * FROM {source_table} LIMIT 0")
            columns = [desc[0] for desc in cursor_rows.description] if cursor_rows else []
            return dict(zip(columns, rows[0], strict=True))

        return await asyncio.to_thread(_fetch)
```

#### 2.2.4 导入操作改造

```python
# src/duckkb/core/mixins/import_.py
"""知识导入能力 Mixin（线程安全版）。"""

import asyncio
from typing import Any

from duckkb.core.base import BaseEngine
from duckkb.logger import logger


class ImportMixin(BaseEngine):
    """知识导入能力 Mixin（线程安全版）。

    导入操作使用 asyncio.Lock 串行化（协程级别），
    数据库操作使用 threading.Lock 串行化（线程级别）。
    """

    def __init__(self, *args, **kwargs) -> None:
        """初始化导入 Mixin。"""
        super().__init__(*args, **kwargs)
        self._import_lock = asyncio.Lock()  # 协程级别锁，防止多个导入并发

    async def import_knowledge_bundle(self, temp_file_path: str) -> dict[str, Any]:
        """导入知识包（线程安全）。"""
        async with self._import_lock:  # 串行化导入请求
            # ... 导入逻辑 ...

    async def _execute_import_in_transaction(
        self,
        nodes_data: list[dict[str, Any]],
        edges_data: list[dict[str, Any]],
    ) -> dict[str, Any]:
        """在单一事务中执行所有导入操作（线程安全）。"""

        def _execute() -> dict[str, Any]:
            with self.transaction() as conn:  # 使用线程安全的事务上下文
                # ... 导入逻辑 ...
                # 直接使用 conn 执行操作，锁已在 transaction 中获取
                pass

        return await asyncio.to_thread(_execute)
```

### 2.3 配置变更

```yaml
# config.yaml
embedding:
  model: text-embedding-3-small
  dim: 1536

log_level: INFO

global:
  chunk_size: 800
  embedding_model: text-embedding-3-small
  tokenizer: jieba

# 新增数据库配置
database:
  mode: file          # "memory" | "file"
  filename: kb.db     # 数据库文件名
  threads: 4          # 并行查询线程数

ontology:
  # ... 本体定义保持不变 ...
```

## 三、并发能力总结

### 3.1 修订后的并发能力

| 场景 | 是否安全 | 说明 |
|------|----------|------|
| 多个查询并发 | ✅ 安全 | 通过线程锁串行化 |
| 导入 + 查询并发 | ✅ 安全 | 通过线程锁串行化 |
| 多个导入并发 | ✅ 安全 | asyncio.Lock + threading.Lock 双重保护 |

### 3.2 性能影响

| 方面 | 影响 | 说明 |
|------|------|------|
| 查询延迟 | 略微增加 | 所有操作串行化，但 DuckDB 本身很快 |
| 吞吐量 | 受限于单连接 | 高并发场景可能成为瓶颈 |
| 数据安全 | ✅ 完全安全 | 无竞态条件风险 |

### 3.3 与原方案对比

| 方案 | 读写分离 | 并发性能 | 实现复杂度 | 可行性 |
|------|----------|----------|------------|--------|
| 原方案 C | 是 | 高 | 高 | ❌ 不可行 |
| 修订方案 | 否 | 中 | 低 | ✅ 可行 |

## 四、实施步骤

### 阶段 1: 配置模型更新

1. 修改 `src/duckkb/core/config/models.py`，添加 `DatabaseConfig`
2. 更新 `CoreConfig` 包含 `database` 字段

### 阶段 2: 数据库连接管理器改造

1. 修改 `src/duckkb/core/mixins/db.py`：
   - 添加 `threading.Lock`
   - 添加 `execute()`、`execute_write()`、`executemany()` 方法
   - 添加 `transaction()` 上下文管理器
   - 支持文件模式

### 阶段 3: 查询和导入操作改造

1. 修改 `src/duckkb/core/mixins/search.py`：使用线程安全方法
2. 修改 `src/duckkb/core/mixins/import_.py`：使用 `transaction()` 上下文

### 阶段 4: 配置和测试

1. 更新 `config.yaml`，添加 `database` 配置节
2. 创建 `tests/test_concurrency.py`，验证并发安全性
3. 运行所有测试，确保向后兼容

## 五、测试验证

### 5.1 已验证的测试

`test_duckdb_concurrency.py` 已验证：
- ✅ 线程安全封装的基本功能
- ✅ 多线程并发读取
- ✅ 多线程并发读写
- ✅ 异步环境下的并发访问
- ✅ 事务的正确执行和回滚

### 5.2 需要新增的测试

```python
# tests/test_concurrency.py
"""Engine 并发能力测试。"""

import asyncio
import pytest

from duckkb import Engine


class TestEngineConcurrency:
    """测试 Engine 的并发安全性。"""

    @pytest.mark.asyncio
    async def test_concurrent_searches(self, engine: Engine) -> None:
        """测试多个查询并发执行。"""
        tasks = [engine.search(f"查询 {i}") for i in range(10)]
        results = await asyncio.gather(*tasks)
        assert len(results) == 10

    @pytest.mark.asyncio
    async def test_import_and_search_concurrent(self, engine: Engine) -> None:
        """测试导入与查询并发执行。"""
        import_task = asyncio.create_task(
            engine.import_knowledge_bundle(...)
        )
        search_tasks = [
            asyncio.create_task(engine.search(f"查询 {i}"))
            for i in range(5)
        ]

        await import_task
        search_results = await asyncio.gather(*search_tasks)
        assert len(search_results) == 5

    @pytest.mark.asyncio
    async def test_sequential_imports(self, engine: Engine) -> None:
        """测试多个导入串行执行。"""
        tasks = [
            engine.import_knowledge_bundle(...)
            for _ in range(2)
        ]
        results = await asyncio.gather(*tasks)
        assert all(r["status"] == "success" for r in results)
```

## 六、内存模式 vs 文件模式对比

### 6.1 用户疑问

> 如果是串行化的话，那我们现在使用内存模式不是更好吗？

这是一个很好的问题。让我分析两种模式的优劣：

### 6.2 对比分析

| 方面 | 内存模式 | 文件模式 |
|------|----------|----------|
| **并发能力** | 串行化 | 串行化（相同） |
| **查询性能** | ⚡ 更高（无磁盘 IO） | 略低（有磁盘 IO） |
| **数据持久化** | ❌ 进程退出后丢失 | ✅ 持久化到文件 |
| **启动速度** | 慢（需从 JSONL 加载） | 快（数据库已存在） |
| **数据安全** | ❌ 崩溃丢失 | ✅ 崩溃不丢失 |
| **内存占用** | 高（数据常驻内存） | 低（按需加载） |

### 6.3 结论

**如果并发能力相同（都是串行化），选择取决于使用场景**：

| 场景 | 推荐模式 | 原因 |
|------|----------|------|
| 高性能查询、数据量小 | 内存模式 | 性能最高 |
| 数据持久化、数据量大 | 文件模式 | 内存占用低 |
| 频繁重启服务 | 文件模式 | 启动快 |
| 数据安全要求高 | 文件模式 | 崩溃不丢失 |

### 6.4 推荐方案

**保持内存模式 + 线程安全封装**（最小改动方案）：

1. **不改变现有架构**：继续使用内存模式
2. **只添加线程锁**：确保并发安全
3. **保留 JSONL 导出**：作为数据备份

```python
# 最小改动：只在 DBMixin 中添加线程锁
class DBMixin(BaseEngine):
    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._conn: duckdb.DuckDBPyConnection | None = None
        self._lock = threading.Lock()  # 新增

    def execute(self, sql: str, params: list | None = None) -> list:
        with self._lock:  # 所有操作加锁
            if params:
                return self.conn.execute(sql, params).fetchall()
            return self.conn.execute(sql).fetchall()
```

### 6.5 可选：未来扩展

如果未来需要文件模式，可以通过配置切换：

```yaml
database:
  mode: memory  # 或 file
```

但当前阶段，**内存模式 + 线程锁**是最简单、最有效的方案。

## 七、风险评估

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 性能下降 | 低 | 内存模式性能足够高 |
| 死锁 | 低 | 锁的获取顺序固定，不会死锁 |
| 数据丢失 | 中 | JSONL 导出作为备份 |

## 八、预期效果

实施完成后：

| 场景 | 当前状态 | 改进后 |
|------|----------|--------|
| 多个查询并发 | ❌ 不安全 | ✅ 安全（线程锁串行化） |
| 导入 + 查询并发 | ❌ 不安全 | ✅ 安全（线程锁串行化） |
| 多个导入并发 | ✅ 安全（asyncio.Lock） | ✅ 安全（双重锁） |
| 数据持久化 | JSONL 导出 | JSONL 导出（不变） |
| 性能影响 | 无 | 极小（锁开销） |

## 九、最终方案总结

**推荐方案：内存模式 + 线程安全封装**

### 改动范围

| 文件 | 改动内容 |
|------|----------|
| `mixins/db.py` | 添加 `threading.Lock` 和线程安全方法 |
| `mixins/search.py` | 使用线程安全的 `execute()` 方法 |
| `mixins/import_.py` | 使用 `transaction()` 上下文管理器 |

### 不改动

- 配置模型（不需要 `DatabaseConfig`）
- 存储模式（继续使用内存模式）
- JSONL 导出逻辑

### 实施步骤

1. 修改 `mixins/db.py`：添加线程锁和安全方法
2. 修改 `mixins/search.py`：使用线程安全方法
3. 修改 `mixins/import_.py`：使用 `transaction()` 上下文
4. 运行测试验证
