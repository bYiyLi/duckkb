# DuckKB 项目代码结构设计

本文提出 DuckKB 的代码结构与分层方案，面向基于 DuckDB 的 MCP 知识库实现。设计遵循项目不变量与质量门禁，覆盖目录布局、包结构、接口边界、数据契约、同步与检索流程、SQL 安全、测试与演进路线。

## 不变量与风险点

- 一库一服：所有操作受 KB_PATH 约束，禁止路径穿越与跨库读写。
- 文件驱动：事实仅通过修改 knowledge-bases/{kb_id}/data/*.jsonl 产生；.build/ 仅存可重建产物。
- 成本优先：embedding 走内容哈希缓存；命中不外呼；记录 last_used 并可 GC。
- 幂等可重建：sync 可重复执行，DB/索引可从 jsonl 完全重建；失败可恢复。
- 查询安全：SQL 只读、强制 LIMIT、结果集大小受控；错误结构化返回。

参考约束与细则见 [SKILL.md](file:///c:/Users/baiyihuan/code/duckkb/.trae/skills/duckkb-standards/SKILL.md) 与 [设计文档.md](file:///c:/Users/baiyihuan/code/duckkb/%E8%AE%BE%E8%AE%91%E6%96%87%E6%A1%A3.md)。

## 顶层目录布局（仓库）

- duckkb/        核心库（包代码）
- examples/      示例知识库与演示脚本（可选）
- scripts/       本地开发/维护脚本（可选，仅调用公开 API）
- tests/         单元与集成测试（pytest）
- docs/          架构图、ER 图等派生文档
- knowledge-bases/        示例 KB 根目录（排除大文件，仅样例）
  - {kb_id}/
    - data/*.jsonl        事实真源（可多文件、多行）
    - .build/             运行时产物（DuckDB 文件、缓存等，可清空）

注：生产时 KB_PATH 指向某个 {kb_id} 目录；仓库可提供最小示例。

## 分层架构与模块边界（无坏味道版）

采用“领域（Domain）→ 应用（Application）→ 基础设施（Infrastructure）→ 接口（Interfaces）”的内向依赖架构，杜绝跨层耦合与上行依赖，确保可测性与可替换性。

- duckkb/domain/
  - models.py：核心实体与值对象（Document、Chunk、SearchHit、Metadata、KBPath 等）
  - errors.py：领域与基础错误分类（DomainError、InfraError、BugError）
  - ports/：领域端口（纯抽象接口）
    - repository.py：SearchIndexRepo、CacheRepo、SchemaRepo、ImportRepo 抽象
    - embedding.py：EmbeddingProvider 抽象（向量生成接口，可为无实现占位）

- duckkb/application/
  - usecases/：用例编排（纯业务流程，无 I/O）
    - sync_kb.py：从记录到索引的流水线，依赖 ports.*
    - smart_search.py：检索编排与融合打分，依赖 ports.*
    - validate_and_import.py：校验与原子写入流程，依赖 ports.*
    - query_sql.py：只读查询与限制策略，依赖 ports.SchemaRepo/SqlGuard
    - get_schema.py：schema_sql 与 ER 图聚合
  - services/：纯函数服务（可被用例复用）
    - segmenter.py：文本分段策略
    - ranker.py：BM25/向量相似度与融合公式

- duckkb/infrastructure/
  - persistence/duckdb/：DuckDB 具体实现
    - connection.py：连接工厂（只读/读写/资源限制）
    - schema.py：表结构初始化与迁移
    - repos.py：SearchIndexRepo、CacheRepo、SchemaRepo 的实现
    - sql_guard.py：SELECT 白名单、LIMIT 注入与结果大小控制
  - filesystem/：文件系统与 KB 环境
    - kb_env.py：KB_PATH 解析与安全路径 join
    - fs_atomic.py：原子写入/替换、jsonl 读写
  - embedding/：向量与缓存
    - cache.py：哈希缓存与 last_used/GC
    - provider_none.py：EmbeddingProvider 的无实现占位（返回 None 或跳过）

- duckkb/interfaces/
  - mcp/tools.py：MCP 工具适配，调用 application.usecases 暴露稳定输入/输出
  - cli/main.py：本地调试 CLI（可选，不引入额外依赖时用 argparse）

- duckkb/types.py：跨层共享的强结构类型（TypedDict/dataclasses），仅包含与领域相关的稳定结构

依赖方向与约束：

- domain 只依赖内置库；不得依赖 application/infrastructure/interfaces
- application 依赖 domain 与其 ports；不得依赖 infrastructure（通过依赖倒置注入端口实现）
- infrastructure 实现 domain.ports；可依赖第三方，但对外仅以端口实现暴露
- interfaces 仅组合 application 用例与类型；不得包含领域逻辑

命名与组织：

- 严禁在 __init__.py 写业务逻辑
- 用例文件名以动词短语命名（sync_kb、smart_search 等），服务为名词性（segmenter、ranker）
- “端口”以抽象类/Protocol 表达；实现位于 infrastructure 层的 repos.py/… 中

## DuckDB Schema（最小可行）

- _sys_search
  - doc_id TEXT、chunk_id INTEGER、priority_weight DOUBLE
  - text TEXT、tokens LIST(TEXT)（可选，便于 BM25/FTS）
  - vector LIST(DOUBLE)（可选，按实现可延后）
  - metadata JSON、content_hash TEXT、updated_at TIMESTAMP
- _sys_cache
  - hash TEXT PRIMARY KEY、vector LIST(DOUBLE)、dim INTEGER
  - created_at TIMESTAMP、last_used TIMESTAMP

策略：初期可先落地 BM25 与 metadata 检索；向量列与缓存表可预留并延后接入。

## 数据契约与 JSONL 形态

- 每行一条记录（Document 或 Chunk）：
  - id、title、content、metadata（任意 KV）、priority_weight（默认 1.0）
  - 允许多文件多行；行内不含跨文档结构
- 校验要求：字段类型、必填项、长度限制、保留字段冲突检查；错误需定位行号与字段名。

## 同步（sync）流程

- 输入：KB_PATH/data/*.jsonl
- 步骤：
  - 扫描文件与行 → 解析为记录 → 分段（按长度/句子）
  - 计算内容哈希 → 查缓存 → 未命中则生成/填充占位
  - 写入 _sys_search（文本、权重、metadata、哈希）与必要派生列
  - 维护 _sys_cache：写入新向量或更新 last_used
- 特性：幂等、可重跑；失败中断不污染事实文件；.build 可清空重建。

## 检索（search）流程

- 输入：query、filters（基于 metadata）、limit、alpha（融合权重可调范围受控）
- 步骤：
  - 文本检索：BM25/FTS 或基于 tokens 的简易倒排
  - 向量检索：若 vector 可用则计算相似度；否则仅文本检索
  - 融合打分：Final = (BM25*0.4 + Vector*0.6) * priority_weight
  - 裁剪与去重：按 doc_id/片段合并策略
  - 返回：结果列表 + metadata 快照

## SQL API 防护

- 仅允许 SELECT（或白名单）；自动追加 LIMIT（默认 1000）；可配置上限
- 结果集大小限制（目标 ≤ 2MB），超出则截断并返回提示
- 异常结构化返回：code、message、details（包含可定位信息）

## MCP 工具接口（稳定输入/输出）

- sync_knowledge_base(kb_path) → {synced: int, affected_tables: [...]}
- get_schema_info(kb_path) → {schema_sql: str, er_mermaid: str}
- smart_search(kb_path, query, filters?, limit?) → {items: [SearchResult], truncated: bool}
- query_raw_sql(kb_path, sql) → {columns: [...], rows: [...], truncated: bool}
- validate_and_import(kb_path, jsonl_lines|file) → {accepted: int, errors: [ErrorEnvelope]}

说明：以上接口通过 duckkb/mcp/tools.py 统一适配对外暴露。

## 配置与约束

- KB_PATH 来源：函数入参优先；若未提供可读取环境变量 DUCKKB_KB_PATH
- 连接与资源：线程/内存上限集中配置；只读/读写模式区分
- 限流与阈值：默认 LIMIT、最大结果大小、最大导入批次、GC 触发条件

## 无坏味道守则

- 单一职责：每个模块/类/函数仅做一件事；超 50 行函数需拆分
- 纯度优先：application/services 使用纯函数；无 I/O 与全局状态
- 不可变数据：领域模型尽量不可变；修改通过返回新值表达
- 明确契约：禁止“随手 dict”，统一用 TypedDict/dataclasses；所有公共接口带完整类型
- 依赖倒置：上层依赖端口，具体实现仅在 infrastructure；通过构造函数或工厂注入
- 资源管理：连接/文件句柄用上下文管理；异常不吞噬，返回结构化错误
- 不滥用单例：配置集中但可注入；禁止隐藏状态与魔法变量

## 测试策略

- 单元测试：
  - kb_env 路径约束、join 与穿越拦截
  - fs_atomic 原子写入与回滚
  - sql_api LIMIT 注入、只读拦截、结果大小截断
  - import_validate 行号/字段名定位与类型校验
  - embedding_cache 命中/未命中与 last_used 更新
- 集成测试：
  - 构建临时 KB_PATH，导入最小 jsonl，sync 后检索与 SQL 查询校验

## 依赖与实现注意

- 最小依赖：duckdb
- 可选依赖：numpy（向量操作）、富分词/embedding 客户端（后期按需引入）
- 禁止在实现前假定依赖存在；如需新增，先在 pyproject 申明并评估必要性。

## 里程碑与落地顺序

1. 建立包骨架与类型定义：types、kb_env、fs_atomic、duckdb_conn、schema
2. 落地 sql_api 与 get_schema_info，完成只读拦截与 LIMIT 注入
3. 实现 import_validate 与 data/ 原子写入闭环
4. 实现 sync 的最小版本（仅文本 + metadata + priority_weight）
5. 实现 smart_search 的文本检索与融合框架（向量可延后）
6. 接入 embedding_cache 与向量检索路径（可用时启用）
7. 完成单元/集成测试与示例 KB
8. MCP 工具适配层与基础 CLI（便于本地调试）

## 自检清单（坏味道审计）

- 分层依赖内向、无环依赖：通过（Domain→Application→Infrastructure→Interfaces 单向）
- __init__.py 不承载业务逻辑：通过（已明确禁止）
- 模块职责单一：通过（用例/服务/端口/实现清晰）
- 全局可变状态：通过（无全局单例，配置可注入）
- 动态字典与弱类型：通过（统一 TypedDict/dataclasses 作为公共契约）
- I/O 混入业务：通过（I/O 全在 infrastructure；application 纯编排）
- 路径与 SQL 安全：通过（kb_env 限制路径；sql_guard 只读+LIMIT+大小限制）
- 结果集与资源控制：通过（集中 limits 管理，连接/文件上下文管理）
- embedding 成本控制：通过（哈希缓存、last_used、可 GC）
- 测试可测性：通过（层间端口可替换，易于 mock 与集成测试）

结论：当前为设计阶段，未发现结构性坏味道。实现阶段需严格对照本清单，避免引入跨层依赖、隐式全局、弱类型与 I/O 逃逸等问题。

## 参考与对齐

- 质量门禁与实现自检：见 [SKILL.md](file:///c:/Users/baiyihuan/code/duckkb/.trae/skills/duckkb-standards/SKILL.md)
- 设计目标与数据流：见 [设计文档.md](file:///c:/Users/baiyihuan/code/duckkb/%E8%AE%BE%E8%AE%91%E6%96%87%E6%A1%A3.md)

本方案在不引入额外依赖的前提下即可逐步落地最小可用能力，并为后续扩展向量检索与高级特性预留接口与边界。
