# 知识库数据模型定义优化方案

## 问题分析

### 当前状态

1. **设计文档与实现不一致**：设计文档声明 `schema.sql` 是 "Source of Truth"，但实际项目中：

   * `schema.sql` 文件不存在

   * 系统表 (`_sys_search`, `_sys_cache`) 的 DDL 定义在 [schema.py](file:///Users/yi/Code/duckkb/src/duckkb/schema.py) 的 `get_sys_schema_ddl()` 函数中

   * 用户表依赖可选的外部 `schema.sql` 文件

2. **当前实现的局限性**：

   * SQL 字符串缺乏类型检查和 IDE 支持

   * 模式定义分散（系统表在代码中，用户表在外部文件）

   * 难以进行版本控制和变更追踪

   * 缺乏字段级别的验证

### 参考设计：Loom 项目

Loom 项目使用 `ontology.yaml` 文件定义知识库的本体结构：

**核心概念**：

* **Nodes（节点）**：实体类型，对应数据库表

* **Edges（边）**：实体间的关系

* **Structs（结构）**：可复用的结构定义（类似 mixin）

* **JSON Schema Draft 7**：用于定义属性结构和验证

**优势**：

* 标准化的 JSON Schema，生态成熟

* 支持向量字段定义

* 支持关系定义

* 强大的数据验证能力

## 优化方案

### 方案选择：统一配置文件

**核心思路**：将所有配置合并到 `config.yaml` 中，包括嵌入配置、日志配置和本体定义。

**优势**：

* ✅ 配置集中：一个文件管理所有配置

* ✅ 标准化：使用 JSON Schema Draft 7

* ✅ 类型验证：强大的数据验证能力

* ✅ 向量支持：原生支持向量字段定义

* ✅ 关系定义：支持实体间关系

* ✅ 简化维护：用户只需维护一个配置文件

### 配置文件格式

#### config.yaml 完整示例

```yaml
embedding:
  model: text-embedding-3-small
  dim: 1536

log_level: INFO

ontology:
  structs:
    TimestampMixin:
      type: object
      properties:
        created_at:
          type: string
          format: date-time
          description: 创建时间
        updated_at:
          type: string
          format: date-time
          description: 更新时间
      required: [created_at]

  nodes:
    Character:
      table: characters
      identity: [id]
      schema:
        type: object
        properties:
          id:
            type: string
            description: 角色唯一标识
          name:
            type: string
            maxLength: 100
            description: 角色名称
          description:
            type: string
            description: 角色描述
          level:
            type: integer
            minimum: 1
            default: 1
            description: 角色等级
          faction:
            type: string
            description: 所属阵营
        required: [id, name]
      vectors:
        description_embedding:
          dim: 1536
          model: text-embedding-3-small
          metric: cosine

    Location:
      table: locations
      identity: [id]
      schema:
        type: object
        properties:
          id:
            type: string
            description: 地点唯一标识
          name:
            type: string
            maxLength: 100
            description: 地点名称
          description:
            type: string
            description: 地点描述
          region:
            type: string
            description: 所属区域
        required: [id, name]

  edges:
    located_at:
      from: Character
      to: Location
      cardinality: N:1
      schema:
        type: object
        properties:
          since:
            type: string
            format: date-time
            description: 定居时间
```

#### 配置结构说明

| 字段                 | 类型     | 必填 | 说明                                 |
| ------------------ | ------ | -- | ---------------------------------- |
| `embedding`        | object | 否  | 嵌入模型配置                             |
| `embedding.model`  | string | 否  | 嵌入模型名称，默认 `text-embedding-3-small` |
| `embedding.dim`    | int    | 否  | 向量维度，默认 1536                       |
| `log_level`        | string | 否  | 日志级别，默认 `INFO`                     |
| `ontology`         | object | 否  | 本体定义                               |
| `ontology.structs` | object | 否  | 可复用结构定义                            |
| `ontology.nodes`   | object | 否  | 节点类型定义                             |
| `ontology.edges`   | object | 否  | 边类型定义                              |

#### 节点定义说明

| 字段         | 类型          | 必填 | 说明                        |
| ---------- | ----------- | -- | ------------------------- |
| `table`    | string      | 是  | 对应的数据库表名                  |
| `identity` | string\[]   | 是  | 标识字段列表（主键）                |
| `schema`   | JSON Schema | 否  | 属性定义（JSON Schema Draft 7） |
| `vectors`  | object      | 否  | 向量字段定义                    |

#### 边定义说明

| 字段            | 类型          | 必填 | 说明                            |
| ------------- | ----------- | -- | ----------------------------- |
| `from`        | string      | 是  | 起始节点类型                        |
| `to`          | string      | 是  | 目标节点类型                        |
| `cardinality` | string      | 否  | 基数：`1:1`, `1:N`, `N:1`, `N:N` |
| `schema`      | JSON Schema | 否  | 边属性定义                         |

#### 向量定义说明

| 字段       | 类型     | 必填 | 说明                            |
| -------- | ------ | -- | ----------------------------- |
| `dim`    | int    | 是  | 向量维度                          |
| `model`  | string | 是  | 嵌入模型名称                        |
| `metric` | string | 否  | 相似度度量：`cosine`, `l2`, `inner` |

### 架构设计

#### 文件结构

```
知识库目录/
├── config.yaml          # 统一配置文件（包含本体定义）
├── data/
│   ├── characters.jsonl
│   └── locations.jsonl
└── .build/
    └── knowledge.db
```

#### 代码结构

```
src/duckkb/
├── ontology/                    # 新增：本体管理模块
│   ├── __init__.py
│   ├── _schema.py              # JSON Schema 元模式定义
│   ├── _models.py              # Pydantic 模型定义
│   ├── _validator.py           # JSON Schema 验证器
│   └── engine.py               # 本体引擎
├── schema.py                   # 重构：从本体生成 DDL
├── config.py                   # 扩展：解析 ontology 配置
└── ...
```

#### 核心模型定义

```python
from typing import Any

from pydantic import BaseModel, ConfigDict, Field, field_validator


class VectorConfig(BaseModel):
    """向量字段配置。"""

    dim: int
    model: str
    metric: str = "cosine"

    @field_validator("dim")
    @classmethod
    def validate_dim(cls, v: int) -> int:
        if v <= 0:
            raise ValueError("dim must be positive")
        return v


class NodeType(BaseModel):
    """节点类型定义。"""

    table: str
    identity: list[str] = Field(default_factory=list)
    json_schema: dict[str, Any] | None = Field(default=None, alias="schema")
    vectors: dict[str, VectorConfig] | None = None
    model_config = ConfigDict(extra="forbid")

    @field_validator("identity")
    @classmethod
    def validate_identity(cls, v: list[str]) -> list[str]:
        if not v:
            raise ValueError("identity required")
        return v


class EdgeType(BaseModel):
    """边类型定义。"""

    from_: str = Field(alias="from")
    to: str
    cardinality: str | None = None
    json_schema: dict[str, Any] | None = Field(default=None, alias="schema")
    model_config = ConfigDict(extra="forbid", populate_by_name=True)


class Ontology(BaseModel):
    """本体定义。"""

    structs: dict[str, Any] = Field(default_factory=dict)
    nodes: dict[str, NodeType] = Field(default_factory=dict)
    edges: dict[str, EdgeType] = Field(default_factory=dict)
    model_config = ConfigDict(extra="forbid")


class EmbeddingConfig(BaseModel):
    """嵌入配置。"""

    model: str = "text-embedding-3-small"
    dim: int = 1536


class KBConfig(BaseModel):
    """知识库配置。"""

    embedding: EmbeddingConfig = Field(default_factory=EmbeddingConfig)
    log_level: str = "INFO"
    ontology: Ontology = Field(default_factory=Ontology)
```

#### DDL 生成逻辑

```python
def generate_node_ddl(node_name: str, node_type: NodeType) -> str:
    """根据节点定义生成 DDL 语句。"""
    columns = []

    schema = node_type.json_schema
    if schema and "properties" in schema:
        for prop_name, prop_def in schema["properties"].items():
            col_type = json_type_to_duckdb(prop_def)
            columns.append(f"    {prop_name} {col_type}")

    if node_type.identity:
        pk_str = ", ".join(node_type.identity)
        columns.append(f"    PRIMARY KEY ({pk_str})")

    columns_str = ",\n".join(columns)
    return f"CREATE TABLE IF NOT EXISTS {node_type.table} (\n{columns_str}\n);"


def json_type_to_duckdb(prop_def: dict) -> str:
    """将 JSON Schema 类型映射到 DuckDB 类型。"""
    json_type = prop_def.get("type", "string")

    type_map = {
        "string": "VARCHAR",
        "integer": "INTEGER",
        "number": "DOUBLE",
        "boolean": "BOOLEAN",
        "array": "JSON",
        "object": "JSON",
    }

    duckdb_type = type_map.get(json_type, "VARCHAR")

    if prop_def.get("format") == "date-time":
        duckdb_type = "TIMESTAMP"

    return duckdb_type
```

### 配置加载流程

1. `AppContext.init(kb_path)` 初始化上下文
2. `KBConfig.from_yaml()` 加载 `config.yaml`（包含 ontology）
3. `init_schema()` 根据本体定义生成 DDL 并执行
4. `sync_knowledge_base()` 同步 JSONL 数据到表

### 与现有系统集成

#### 系统表处理

系统表 (`_sys_search`, `_sys_cache`) 继续在代码中定义，不放入配置文件：

```python
def get_sys_schema_ddl(embedding_dim: int) -> str:
    return f"""
CREATE TABLE IF NOT EXISTS _sys_search (...);
CREATE TABLE IF NOT EXISTS _sys_cache (...);
"""
```

#### 向量字段处理

当节点定义了 `vectors` 时，同步过程中自动生成向量嵌入：

```python
async def sync_node_vectors(node_type: NodeType, records: list[dict]):
    for vec_name, vec_config in node_type.vectors.items():
        source_field = vec_name.replace("_embedding", "")
        texts = [r.get(source_field, "") for r in records]
        embeddings = await get_embeddings(texts, vec_config.model)
```

### 向后兼容

* 如果 `config.yaml` 中没有 `ontology` 段，则不创建用户表

* 保留 `schema.sql` 作为备选方案（优先级：config.yaml > schema.sql）

* 现有知识库无需修改即可继续工作

## 实施步骤

### Phase 1: 本体模型定义

1. 创建 `src/duckkb/ontology/` 目录
2. 实现 `_models.py` - Pydantic 模型定义
3. 实现 `_schema.py` - JSON Schema 元模式
4. 实现 `_validator.py` - JSON Schema 验证器

### Phase 2: 配置模型扩展

1. 更新 `config.py` - 添加 Ontology 模型
2. 更新 `KBConfig.from_yaml()` - 解析 ontology 配置

### Phase 3: DDL 生成重构

1. 实现 `ontology/engine.py` - 本体加载和 DDL 生成
2. 重构 `schema.py` - 使用本体生成 DDL
3. 更新 `sync.py` - 支持向量字段

### Phase 4: 测试与文档

1. 更新测试用例
2. 更新设计文档

## 预期收益

1. **配置集中**：一个文件管理所有配置
2. **标准化**：使用 JSON Schema Draft 7，生态成熟
3. **类型验证**：强大的数据验证能力
4. **向量支持**：原生支持向量字段定义
5. **关系定义**：支持实体间关系
6. **可复用**：structs 支持结构复用
7. **与 Loom 兼容**：便于未来项目整合

## 风险与缓解

| 风险              | 缓解措施                    |
| --------------- | ----------------------- |
| YAML 格式错误       | Pydantic 验证 + 详细错误提示    |
| JSON Schema 复杂度 | 提供示例和文档                 |
| 表结构变更迁移         | 提供 DDL 迁移脚本生成工具         |
| 类型覆盖不全          | 支持原始 SQL 回退（schema.sql） |

