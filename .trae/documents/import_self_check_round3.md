# 导入逻辑第三轮自检报告

## 已修复的问题 ✅

| 问题                    | 状态    |
| --------------------- | ----- |
| 影子导出导致数据丢失            | ✅ 已修复 |
| 索引构建逻辑错误              | ✅ 已修复 |
| 删除节点时未处理相关边           | ✅ 已修复 |
| 向量嵌入无法计算              | ✅ 已修复 |
| 异常处理和清理               | ✅ 已修复 |
| 空数据处理                 | ✅ 已修复 |
| DuckDB DELETE 不返回删除行数 | ✅ 已修复 |
| COPY TO FORMAT 不匹配    | ✅ 已修复 |
| 原子替换目录竞态条件            | ✅ 已修复 |
| deleted\_ids 参数未使用    | ✅ 已修复 |
| 向量保存缺少事务保护            | ✅ 已修复 |
| 边表存在性检查               | ✅ 已修复 |

***

## 新发现的问题

### 1. 🔴 严重：Upsert 操作覆盖 \_\_created\_at

**位置**: `_upsert_nodes_sync` (第 418-420 行), `_upsert_edges_sync` (第 618-620 行)

**问题**: 当更新已存在的记录时，`__created_at` 会被设置为当前时间，而不是保留原始创建时间。这会导致记录的创建时间丢失。

```python
record["__created_at"] = now  # 应该只在插入时设置
record["__updated_at"] = now
```

**修复方案**: 使用 `INSERT OR REPLACE` 时，应该先查询现有记录的 `__created_at`，或者在 SQL 中使用 `COALESCE` 保留原值。

***

### 2. 🔴 严重：Upsert 时旧索引条目未删除

**位置**: `_build_index_for_ids_sync` (第 757-774 行)

**问题**: 当 upsert 一个已存在的记录时，会插入新的索引条目，但旧的索引条目（可能有不同的 chunk 数量）没有被删除。这会导致索引膨胀和重复。

```python
# 当前实现：直接 INSERT OR REPLACE
# 但如果原来有 3 个 chunk，现在只有 2 个，第 3 个 chunk 的索引不会被删除
self.conn.execute(
    f"INSERT OR REPLACE INTO {SEARCH_INDEX_TABLE} ..."
)
```

**修复方案**: 在构建新索引前，先删除该记录的所有旧索引条目。

***

### 3. 🟡 中等：边表可能不存在

**位置**: `_upsert_edges_sync` (第 594 行), `_delete_edges_sync` (第 659 行)

**问题**: 这些方法假设边表已存在，但没有检查。如果边表不存在，会抛出异常。

```python
table_name = f"edge_{edge_type}"  # 假设表存在
```

**修复方案**: 添加表存在性检查，或在 ontology 定义边时自动创建表。

***

### 4. 🟡 中等：空内容返回非空列表

**位置**: `_chunk_text_sync` (第 790-796 行)

**问题**: 如果文本内容为空字符串，返回 `[""]` 而不是空列表。这会导致创建无意义的空索引条目。

```python
if len(text) <= chunk_size:
    return [text]  # text 为空时返回 [""]
```

**修复方案**: 添加空字符串检查。

***

### 5. 🟡 中等：缓存表可能不存在

**位置**: `_get_or_compute_fts_sync` (第 821-836 行), `_get_or_compute_vector_sync` (第 852-860 行)

**问题**: 这些方法假设缓存表已存在，但没有检查。如果缓存表不存在，会抛出异常。

**修复方案**: 在使用前检查并创建缓存表。

***

### 6. 🟢 轻微：索引表可能不存在

**位置**: `_build_index_for_ids_sync`, `_delete_index_for_ids`

**问题**: 这些方法假设索引表已存在，但没有检查。

**修复方案**: 在使用前检查并创建索引表。

***

### 7. 🟢 轻微：缺少导入锁

**位置**: 整个导入流程

**问题**: 没有锁机制防止多个导入操作同时执行，可能导致数据竞争。

**修复方案**: 添加文件锁或分布式锁。

***

## 修复优先级

| 优先级 | 问题                          | 影响      |
| --- | --------------------------- | ------- |
| P0  | Upsert 操作覆盖 \_\_created\_at | 数据完整性问题 |
| P0  | Upsert 时旧索引条目未删除            | 索引膨胀    |
| P1  | 边表可能不存在                     | 运行时异常   |
| P1  | 空内容返回非空列表                   | 无意义索引条目 |
| P1  | 缓存表可能不存在                    | 运行时异常   |
| P2  | 索引表可能不存在                    | 运行时异常   |
| P3  | 缺少导入锁                       | 数据竞争    |

***

## 建议的修复计划

### Phase 1: 修复数据完整性问题

1. 修复 `__created_at` 覆盖问题 - 使用 SQL COALESCE 或先查询后更新
2. 修复索引条目残留问题 - 在构建新索引前删除旧索引

### Phase 2: 修复健壮性问题

1. 添加边表存在性检查
2. 添加空内容检查
3. 添加缓存表/索引表存在性检查

### Phase 3: 添加并发控制

1. 添加导入锁（可选）

